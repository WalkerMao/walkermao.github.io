<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://kit.fontawesome.com/123ecac47c.js" crossorigin="anonymous"></script><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="shortcut icon" type="image/png" href="/assets/portfolio.png">
<title>Notes on "C++ Primer": Chapter 6. Functions</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Notes on “C++ Primer”: Chapter 6. Functions | Weikai’s blog.</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Notes on “C++ Primer”: Chapter 6. Functions" />
<meta name="author" content="Weikai Mao" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chapter 6. Functions" />
<meta property="og:description" content="Chapter 6. Functions" />
<link rel="canonical" href="http://localhost:4000/notes-on-c++-primer-chapter-6-functions.html" />
<meta property="og:url" content="http://localhost:4000/notes-on-c++-primer-chapter-6-functions.html" />
<meta property="og:site_name" content="Weikai’s blog." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-06T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Notes on “C++ Primer”: Chapter 6. Functions" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Weikai Mao"},"dateModified":"2022-05-06T00:00:00+08:00","datePublished":"2022-05-06T00:00:00+08:00","description":"Chapter 6. Functions","headline":"Notes on “C++ Primer”: Chapter 6. Functions","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/notes-on-c++-primer-chapter-6-functions.html"},"url":"http://localhost:4000/notes-on-c++-primer-chapter-6-functions.html"}</script>
<!-- End Jekyll SEO tag -->


<meta name="google-site-verification" content="wXp8C1QlYKCpKxfXyFfQXEv9l5fJvcOi53ofYmOcaSA" />
<meta name="msvalidate.01" content="97F0BB32D312B808156DE357EA8474D3" />
<meta name="yandex-verification" content="690106a82d8966ab" />

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[", "\\]"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno"
      }
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    


  







</head>
  <body>
    <main class="container">
      <section class="about">
        <a href="/" class="iconlink"> 
          <h3> 
            <i class="fas fa-home"></i> HOME 
          </h3> 
        </a>
        <a href="/"> <img src="/assets/portfolio.png" alt="Weikai Mao"></a>
        <h2 id="title"> Weikai Mao </h2>
        <p style="font-size:90%" class="tagline">maoweikai123@outlook.com</p>
        
        <ul class="social"><a href="https://github.com/WalkerMao">
              <li>
                <i class="fab fa-github"></i>
              </li>
            </a><a href="https://www.linkedin.com/in/weikai-mao-000249124">
              <li>
                <i class="fab fa-linkedin"></i>
              </li>
            </a><a href="/wechat-qr-code.html">
              <li>
                <i class="fab fa-weixin"></i>
              </li>
            </a></ul><h3 style="color:gray; font-weight:normal"> Categories: </h3>
            <ul class="post-categories" style="max-width:225px;">
              
                  <a class="post-link" href="/"> <li style="padding: 4px 8px;"> All </li> </a>
              
                  <a class="post-link" href="/categories/cs"> <li style="padding: 4px 8px;"> CS </li> </a>
              
                  <a class="post-link" href="/categories/cv"> <li style="padding: 4px 8px;"> CV </li> </a>
              
                  <a class="post-link" href="/categories/dl"> <li style="padding: 4px 8px;"> DL </li> </a>
              
                  <a class="post-link" href="/categories/fe"> <li style="padding: 4px 8px;"> FE </li> </a>
              
                  <a class="post-link" href="/categories/math"> <li style="padding: 4px 8px;"> Math </li> </a>
              
                  <a class="post-link" href="/categories/ml"> <li style="padding: 4px 8px;"> ML </li> </a>
              
                  <a class="post-link" href="/categories/nlp"> <li style="padding: 4px 8px;"> NLP </li> </a>
              
                  <a class="post-link" href="/categories/stat"> <li style="padding: 4px 8px;"> Stat </li> </a>
              
                  <a class="post-link" href="/categories/杂"> <li style="padding: 4px 8px;"> 杂 </li> </a>
              
            </ul><p>&copy; 2023 </p>

      </section>
      <section class="content">
        <div class="sidebar">
  <ul><li><a href="#chapter-6-functions">Chapter 6. Functions</a><ul><li><a href="#61-function-basics">6.1 Function Basics</a><ul><li><a href="#writing-a-function">Writing a Function</a></li><li><a href="#calling-a-function">Calling a Function</a></li><li><a href="#parameters-and-arguments">Parameters and Arguments</a></li><li><a href="#function-parameter-list">Function Parameter List</a></li><li><a href="#function-return-type">Function Return Type</a></li></ul></li><li><a href="#611-local-objects">6.1.1 Local Objects</a><ul><li><a href="#automatic-objects">Automatic Objects</a></li><li><a href="#local-static-objects">Local <code class="language-plaintext highlighter-rouge">static</code> Objects</a></li></ul></li><li><a href="#612-function-declarations">6.1.2 Function Declarations</a><ul><li><a href="#function-declarations-go-in-header-files">Function Declarations Go in Header Files</a></li></ul></li><li><a href="#613-separate-compilation">6.1.3 Separate Compilation</a><ul><li><a href="#compiling-and-linking-multiple-source-files">Compiling and Linking Multiple Source Files</a></li></ul></li></ul></li><li><a href="#62-argument-passing">6.2 Argument Passing</a><ul><li><a href="#621-passing-arguments-by-value">6.2.1 Passing Arguments by Value</a><ul><li><a href="#pointer-parameters">Pointer Parameters</a></li></ul></li><li><a href="#622-passing-arguments-by-reference">6.2.2 Passing Arguments by Reference</a><ul><li><a href="#using-references-to-avoid-copies">Using References to Avoid Copies</a></li><li><a href="#using-reference-parameters-to-return-additional-information">Using Reference Parameters to Return Additional Information</a></li></ul></li><li><a href="#623-const-parameters-and-arguments">6.2.3 <code class="language-plaintext highlighter-rouge">const</code> Parameters and Arguments</a><ul><li><a href="#pointer-or-reference-parameters-and-const">Pointer or Reference Parameters and <code class="language-plaintext highlighter-rouge">const</code></a></li><li><a href="#use-reference-to-const-when-possible">Use Reference to <code class="language-plaintext highlighter-rouge">const</code> When Possible</a></li></ul></li><li><a href="#624-array-parameters">6.2.4 Array Parameters</a><ul><li><a href="#using-a-marker-to-specify-the-extent-of-an-array">Using a Marker to Specify the Extent of an Array</a></li><li><a href="#using-the-standard-library-conventions">Using the Standard Library Conventions</a></li><li><a href="#explicitly-passing-a-size-parameter">Explicitly Passing a Size Parameter</a></li><li><a href="#array-parameters-and-const">Array Parameters and <code class="language-plaintext highlighter-rouge">const</code></a></li><li><a href="#array-reference-parameters">Array Reference Parameters</a></li><li><a href="#passing-a-multidimensional-array">Passing a Multidimensional Array</a></li></ul></li><li><a href="#625-main-handling-command-line-options">6.2.5 <code class="language-plaintext highlighter-rouge">main</code>: Handling Command-Line Options</a></li><li><a href="#626-functions-with-varying-parameters">6.2.6 Functions with Varying Parameters</a><ul><li><a href="#initializer_list-parameters"><code class="language-plaintext highlighter-rouge">initializer_list</code> Parameters</a></li><li><a href="#ellipsis-parameters">Ellipsis Parameters</a></li></ul></li></ul></li><li><a href="#63-return-types-and-the-return-statement">6.3 Return Types and the return Statement</a><ul><li><a href="#631-functions-with-no-return-value">6.3.1 Functions with No Return Value</a></li><li><a href="#632-functions-that-return-a-value">6.3.2 Functions That Return a Value</a><ul><li><a href="#how-values-are-returned">How Values Are Returned</a></li><li><a href="#never-return-a-reference-or-pointer-to-a-local-object">Never Return a Reference or Pointer to a Local Object</a></li><li><a href="#functions-that-return-class-types-and-the-call-operator">Functions That Return Class Types and the Call Operator</a></li><li><a href="#reference-returns-are-lvalues">Reference Returns Are Lvalues</a></li><li><a href="#list-initializing-the-return-value">List Initializing the Return Value</a></li><li><a href="#return-from-main">Return from <code class="language-plaintext highlighter-rouge">main</code></a></li><li><a href="#recursion">Recursion</a></li></ul></li><li><a href="#633-returning-a-pointer-to-an-array">6.3.3 Returning a Pointer to an Array</a><ul><li><a href="#declaring-a-function-that-returns-a-pointer-to-an-array">Declaring a Function That Returns a Pointer to an Array</a></li><li><a href="#using-a-trailing-return-type">Using a Trailing Return Type</a></li><li><a href="#using-decltype">Using <code class="language-plaintext highlighter-rouge">decltype</code></a></li></ul></li></ul></li><li><a href="#64-overloaded-functions">6.4 Overloaded Functions</a><ul><li><a href="#defining-overloaded-functions">Defining Overloaded Functions</a></li><li><a href="#determining-whether-two-parameter-types-differ">Determining Whether Two Parameter Types Differ</a></li><li><a href="#overloading-and-const-parameters">Overloading and <code class="language-plaintext highlighter-rouge">const</code> Parameters</a></li><li><a href="#const_cast-and-overloading"><code class="language-plaintext highlighter-rouge">const_cast</code> and Overloading</a></li><li><a href="#calling-an-overloaded-function">Calling an Overloaded Function</a></li></ul></li><li><a href="#641-overloading-and-scope">6.4.1 Overloading and Scope</a></li></ul></li><li><a href="#65-features-for-specialized-uses">6.5 Features for Specialized Uses</a><ul><li><a href="#651-default-arguments">6.5.1 Default Arguments</a><ul><li><a href="#calling-functions-with-default-arguments">Calling Functions with Default Arguments</a></li><li><a href="#default-argument-declarations">Default Argument Declarations</a></li><li><a href="#default-argument-initializers">Default Argument Initializers</a></li></ul></li><li><a href="#652-inline-and-constexpr-functions">6.5.2 <code class="language-plaintext highlighter-rouge">inline</code> and <code class="language-plaintext highlighter-rouge">constexpr</code> Functions</a><ul><li><a href="#inline-functions-avoid-function-call-overhead"><code class="language-plaintext highlighter-rouge">inline</code> Functions Avoid Function Call Overhead</a></li><li><a href="#constexpr-functions"><code class="language-plaintext highlighter-rouge">constexpr</code> Functions</a></li><li><a href="#put-inline-and-constexpr-functions-in-header-files">Put <code class="language-plaintext highlighter-rouge">inline</code> and <code class="language-plaintext highlighter-rouge">constexpr</code> Functions in Header Files</a></li></ul></li><li><a href="#653-aids-for-debugging">6.5.3 Aids for Debugging</a><ul><li><a href="#the-assert-preprocessor-macro">The <code class="language-plaintext highlighter-rouge">assert</code> Preprocessor Macro</a></li><li><a href="#the-ndebug-preprocessor-variable">The <code class="language-plaintext highlighter-rouge">NDEBUG</code> Preprocessor Variable</a></li></ul></li></ul></li><li><a href="#66-function-matching">6.6 Function Matching</a><ul><li><a href="#determining-the-candidate-and-viable-functions">Determining the Candidate and Viable Functions</a></li><li><a href="#finding-the-best-match-if-any">Finding the Best Match, If Any</a></li><li><a href="#function-matching-with-multiple-parameters">Function Matching with Multiple Parameters</a></li></ul></li><li><a href="#661-argument-type-conversions">6.6.1 Argument Type Conversions</a><ul><li><a href="#matches-requiring-promotion-or-arithmetic-conversion">Matches Requiring Promotion or Arithmetic Conversion</a></li><li><a href="#function-matching-and-const-arguments">Function Matching and <code class="language-plaintext highlighter-rouge">const</code> Arguments</a></li></ul></li></ul></li><li><a href="#67-pointers-to-functions">6.7 Pointers to Functions</a><ul><li><a href="#using-function-pointers">Using Function Pointers</a></li><li><a href="#pointers-to-overloaded-functions">Pointers to Overloaded Functions</a></li><li><a href="#function-pointer-parameters">Function Pointer Parameters</a></li><li><a href="#returning-a-pointer-to-function">Returning a Pointer to Function</a></li><li><a href="#using-auto-or-decltype-for-function-pointer-types">Using <code class="language-plaintext highlighter-rouge">auto</code> or <code class="language-plaintext highlighter-rouge">decltype</code> for Function Pointer Types</a></li></ul></li></ul></li><li><a href="#chapter-summary">Chapter Summary</a></li><li><a href="#defined-terms">Defined Terms</a></li></ul></li><li><a href="#references">References</a></li></ul>

</div><div class="post-container" id="viewpoint">
  <a class="post-link" href="/notes-on-c++-primer-chapter-6-functions.html">
    <h2 class="post-title">Notes on &quot;C++ Primer&quot;: Chapter 6. Functions</h2>
  </a>
  <div class="post-meta">
    <div>
      <ul class="post-categories"><a class="post-link" href="/categories/cs"> <li>CS</li> </a></ul>
      <ul class="post-tags"><a class="post-link" href="/tags/c++"> <li>C++</li> </a></ul>
    </div>
    <div class="post-date">
      <i class="icon-calendar"></i>
      May 6, 2022
    </div>
  </div>
  <div style="line-height:77%;">
    <br>
  </div>
  <div class="post"><div class="toc">
        <ul><li><a href="#chapter-6-functions">Chapter 6. Functions</a><ul><li><a href="#61-function-basics">6.1 Function Basics</a><ul><li><a href="#writing-a-function">Writing a Function</a></li><li><a href="#calling-a-function">Calling a Function</a></li><li><a href="#parameters-and-arguments">Parameters and Arguments</a></li><li><a href="#function-parameter-list">Function Parameter List</a></li><li><a href="#function-return-type">Function Return Type</a></li></ul></li><li><a href="#611-local-objects">6.1.1 Local Objects</a><ul><li><a href="#automatic-objects">Automatic Objects</a></li><li><a href="#local-static-objects">Local <code class="language-plaintext highlighter-rouge">static</code> Objects</a></li></ul></li><li><a href="#612-function-declarations">6.1.2 Function Declarations</a><ul><li><a href="#function-declarations-go-in-header-files">Function Declarations Go in Header Files</a></li></ul></li><li><a href="#613-separate-compilation">6.1.3 Separate Compilation</a><ul><li><a href="#compiling-and-linking-multiple-source-files">Compiling and Linking Multiple Source Files</a></li></ul></li></ul></li><li><a href="#62-argument-passing">6.2 Argument Passing</a><ul><li><a href="#621-passing-arguments-by-value">6.2.1 Passing Arguments by Value</a><ul><li><a href="#pointer-parameters">Pointer Parameters</a></li></ul></li><li><a href="#622-passing-arguments-by-reference">6.2.2 Passing Arguments by Reference</a><ul><li><a href="#using-references-to-avoid-copies">Using References to Avoid Copies</a></li><li><a href="#using-reference-parameters-to-return-additional-information">Using Reference Parameters to Return Additional Information</a></li></ul></li><li><a href="#623-const-parameters-and-arguments">6.2.3 <code class="language-plaintext highlighter-rouge">const</code> Parameters and Arguments</a><ul><li><a href="#pointer-or-reference-parameters-and-const">Pointer or Reference Parameters and <code class="language-plaintext highlighter-rouge">const</code></a></li><li><a href="#use-reference-to-const-when-possible">Use Reference to <code class="language-plaintext highlighter-rouge">const</code> When Possible</a></li></ul></li><li><a href="#624-array-parameters">6.2.4 Array Parameters</a><ul><li><a href="#using-a-marker-to-specify-the-extent-of-an-array">Using a Marker to Specify the Extent of an Array</a></li><li><a href="#using-the-standard-library-conventions">Using the Standard Library Conventions</a></li><li><a href="#explicitly-passing-a-size-parameter">Explicitly Passing a Size Parameter</a></li><li><a href="#array-parameters-and-const">Array Parameters and <code class="language-plaintext highlighter-rouge">const</code></a></li><li><a href="#array-reference-parameters">Array Reference Parameters</a></li><li><a href="#passing-a-multidimensional-array">Passing a Multidimensional Array</a></li></ul></li><li><a href="#625-main-handling-command-line-options">6.2.5 <code class="language-plaintext highlighter-rouge">main</code>: Handling Command-Line Options</a></li><li><a href="#626-functions-with-varying-parameters">6.2.6 Functions with Varying Parameters</a><ul><li><a href="#initializer_list-parameters"><code class="language-plaintext highlighter-rouge">initializer_list</code> Parameters</a></li><li><a href="#ellipsis-parameters">Ellipsis Parameters</a></li></ul></li></ul></li><li><a href="#63-return-types-and-the-return-statement">6.3 Return Types and the return Statement</a><ul><li><a href="#631-functions-with-no-return-value">6.3.1 Functions with No Return Value</a></li><li><a href="#632-functions-that-return-a-value">6.3.2 Functions That Return a Value</a><ul><li><a href="#how-values-are-returned">How Values Are Returned</a></li><li><a href="#never-return-a-reference-or-pointer-to-a-local-object">Never Return a Reference or Pointer to a Local Object</a></li><li><a href="#functions-that-return-class-types-and-the-call-operator">Functions That Return Class Types and the Call Operator</a></li><li><a href="#reference-returns-are-lvalues">Reference Returns Are Lvalues</a></li><li><a href="#list-initializing-the-return-value">List Initializing the Return Value</a></li><li><a href="#return-from-main">Return from <code class="language-plaintext highlighter-rouge">main</code></a></li><li><a href="#recursion">Recursion</a></li></ul></li><li><a href="#633-returning-a-pointer-to-an-array">6.3.3 Returning a Pointer to an Array</a><ul><li><a href="#declaring-a-function-that-returns-a-pointer-to-an-array">Declaring a Function That Returns a Pointer to an Array</a></li><li><a href="#using-a-trailing-return-type">Using a Trailing Return Type</a></li><li><a href="#using-decltype">Using <code class="language-plaintext highlighter-rouge">decltype</code></a></li></ul></li></ul></li><li><a href="#64-overloaded-functions">6.4 Overloaded Functions</a><ul><li><a href="#defining-overloaded-functions">Defining Overloaded Functions</a></li><li><a href="#determining-whether-two-parameter-types-differ">Determining Whether Two Parameter Types Differ</a></li><li><a href="#overloading-and-const-parameters">Overloading and <code class="language-plaintext highlighter-rouge">const</code> Parameters</a></li><li><a href="#const_cast-and-overloading"><code class="language-plaintext highlighter-rouge">const_cast</code> and Overloading</a></li><li><a href="#calling-an-overloaded-function">Calling an Overloaded Function</a></li></ul></li><li><a href="#641-overloading-and-scope">6.4.1 Overloading and Scope</a></li></ul></li><li><a href="#65-features-for-specialized-uses">6.5 Features for Specialized Uses</a><ul><li><a href="#651-default-arguments">6.5.1 Default Arguments</a><ul><li><a href="#calling-functions-with-default-arguments">Calling Functions with Default Arguments</a></li><li><a href="#default-argument-declarations">Default Argument Declarations</a></li><li><a href="#default-argument-initializers">Default Argument Initializers</a></li></ul></li><li><a href="#652-inline-and-constexpr-functions">6.5.2 <code class="language-plaintext highlighter-rouge">inline</code> and <code class="language-plaintext highlighter-rouge">constexpr</code> Functions</a><ul><li><a href="#inline-functions-avoid-function-call-overhead"><code class="language-plaintext highlighter-rouge">inline</code> Functions Avoid Function Call Overhead</a></li><li><a href="#constexpr-functions"><code class="language-plaintext highlighter-rouge">constexpr</code> Functions</a></li><li><a href="#put-inline-and-constexpr-functions-in-header-files">Put <code class="language-plaintext highlighter-rouge">inline</code> and <code class="language-plaintext highlighter-rouge">constexpr</code> Functions in Header Files</a></li></ul></li><li><a href="#653-aids-for-debugging">6.5.3 Aids for Debugging</a><ul><li><a href="#the-assert-preprocessor-macro">The <code class="language-plaintext highlighter-rouge">assert</code> Preprocessor Macro</a></li><li><a href="#the-ndebug-preprocessor-variable">The <code class="language-plaintext highlighter-rouge">NDEBUG</code> Preprocessor Variable</a></li></ul></li></ul></li><li><a href="#66-function-matching">6.6 Function Matching</a><ul><li><a href="#determining-the-candidate-and-viable-functions">Determining the Candidate and Viable Functions</a></li><li><a href="#finding-the-best-match-if-any">Finding the Best Match, If Any</a></li><li><a href="#function-matching-with-multiple-parameters">Function Matching with Multiple Parameters</a></li></ul></li><li><a href="#661-argument-type-conversions">6.6.1 Argument Type Conversions</a><ul><li><a href="#matches-requiring-promotion-or-arithmetic-conversion">Matches Requiring Promotion or Arithmetic Conversion</a></li><li><a href="#function-matching-and-const-arguments">Function Matching and <code class="language-plaintext highlighter-rouge">const</code> Arguments</a></li></ul></li></ul></li><li><a href="#67-pointers-to-functions">6.7 Pointers to Functions</a><ul><li><a href="#using-function-pointers">Using Function Pointers</a></li><li><a href="#pointers-to-overloaded-functions">Pointers to Overloaded Functions</a></li><li><a href="#function-pointer-parameters">Function Pointer Parameters</a></li><li><a href="#returning-a-pointer-to-function">Returning a Pointer to Function</a></li><li><a href="#using-auto-or-decltype-for-function-pointer-types">Using <code class="language-plaintext highlighter-rouge">auto</code> or <code class="language-plaintext highlighter-rouge">decltype</code> for Function Pointer Types</a></li></ul></li></ul></li><li><a href="#chapter-summary">Chapter Summary</a></li><li><a href="#defined-terms">Defined Terms</a></li></ul></li><li><a href="#references">References</a></li></ul>

      </div>
      </br><h2 id="chapter-6-functions">Chapter 6. Functions</h2>

<p>This chapter describes how to define and declare functions.</p>

<p>A function is a block of code with a name. We execute the code by calling the function.</p>

<h3 id="61-function-basics">6.1 Function Basics</h3>

<p>A function definition typically consists of a return type, a name, a list of zero or more parameters, and a body.</p>

<p>We execute a function through the call operator, which is a pair of parentheses. Inside the parentheses is a comma-separated list of arguments. The arguments are used to initialize the function’s parameters.</p>

<h5 id="writing-a-function">Writing a Function</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// factorial</span>
<span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// local variable to hold the result as we calculate it</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">*=</span> <span class="n">val</span><span class="o">--</span><span class="p">;</span> <span class="c1">// assign ret * val to ret and decrement val</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">// return the result</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">plus</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="calling-a-function">Calling a Function</h5>

<p>A function call does two things: It initializes the function’s parameters from the corresponding arguments, and it transfers control to that function, then execution of the called function begins.</p>

<p>A call to <code class="language-plaintext highlighter-rouge">fact</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">fact</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</code></pre></div></div>

<p>is equivalent to</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// initialize val from the literal 5</span>
<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// code from the body of fact</span>
<span class="k">while</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">*=</span> <span class="n">val</span><span class="o">--</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">// initialize j as a copy of ret</span>
</code></pre></div></div>

<h5 id="parameters-and-arguments">Parameters and Arguments</h5>

<p>Arguments are the initializers for a function’s parameters. We
have no guarantees about the order in which arguments are evaluated (§ 4.1.3, p. 137). The compiler is free to evaluate the arguments in whatever order it prefers.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fact</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span> <span class="c1">// ok: argument is converted to int; this is equivalent to fact(3);</span>
</code></pre></div></div>

<h5 id="function-parameter-list">Function Parameter List</h5>

<p>A function’s parameter list can be empty but cannot be omitted.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="c1">// implicit void parameter list</span>
<span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="c1">// explicit void parameter list</span>
</code></pre></div></div>

<h5 id="function-return-type">Function Return Type</h5>

<p>Most types can be used as the return type of a function. In particular, the return type can be <code class="language-plaintext highlighter-rouge">void</code>, which means that the function does not return a value. However, the return type may not be an array type (§ 3.5, p. 113) or a function type. However, a function may return a pointer to an array or a function.</p>

<h4 id="611-local-objects">6.1.1 Local Objects</h4>

<p>In C++, names have scope (§ 2.2.4, p. 48), and objects have lifetimes. It is important to understand both of these concepts.</p>

<ul>
  <li>
    <p>The <strong>scope</strong> of a name is the part of the program’s text in which that name is visible.</p>
  </li>
  <li>
    <p>The <strong>lifetime</strong> of an object is the time during the program’s execution that the object exists.</p>
  </li>
</ul>

<p>The body of a function is a statement block that forms a new scope in which we can define variables. Parameters and variables defined inside a function body are referred to as <strong>local variables</strong>. They are “local” to that function and hide declarations of the same name made in an outer scope.</p>

<h5 id="automatic-objects">Automatic Objects</h5>

<p>Objects that exist only while a block is executing are known as automatic objects. After execution exits a block, the values of the automatic objects created in that block are undefined.</p>

<p>Parameters are automatic objects. Storage for the parameters is allocated when the function begins. Parameters are defined in the scope of the function body. Hence they are destroyed when the function terminates.</p>

<p>Automatic objects corresponding to local variables are initialized if their definition contains an initializer.</p>

<h5 id="local-static-objects">Local <code class="language-plaintext highlighter-rouge">static</code> Objects</h5>

<p>It can be useful to have a local variable whose lifetime continues across calls to the function. We obtain such objects by defining a local variable as <code class="language-plaintext highlighter-rouge">static</code>. Each local <code class="language-plaintext highlighter-rouge">static</code> object is initialized before the first time execution passes through the object’s definition. Local statics are not destroyed when a function ends; they are destroyed when the program terminates.</p>

<p>As a trivial example, here is a function that counts how many times it is called:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">count_calls</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">size_t</span> <span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// value will persist across calls</span>
    <span class="k">return</span> <span class="o">++</span><span class="n">ctr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count_calls</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This program will print the numbers from 1 through 10 inclusive.</p>

<p>Before control flows through the definition of ctr for the first time, <code class="language-plaintext highlighter-rouge">ctr</code> is created and given an initial value of 0. Whenever count_calls is executed, the variable <code class="language-plaintext highlighter-rouge">ctr</code> already exists and has whatever value was in that variable the last time the function exited.</p>

<h4 id="612-function-declarations">6.1.2 Function Declarations</h4>

<p>A function declaration (a.k.a. function prototype) is just like a function definition except that a declaration has no function body.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">beg</span><span class="p">,</span>
           <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">end</span><span class="p">);</span>
</code></pre></div></div>

<p>Because a function declaration has no body, there is no need for parameter names, but they can help understanding the function.</p>

<h5 id="function-declarations-go-in-header-files">Function Declarations Go in Header Files</h5>

<p>As with variables, functions should also be declared in header files and defined in source files.</p>

<p>The source file that defines a function should include the header that contains that function’s declaration. That way the compiler will verify that the definition and declaration are consistent.</p>

<h4 id="613-separate-compilation">6.1.3 Separate Compilation</h4>

<p>We may want to store the various parts of the program in separate files. C++ supports what is commonly known as separate compilation to lets us split our programs into several files, each of which can be compiled independently.</p>

<h5 id="compiling-and-linking-multiple-source-files">Compiling and Linking Multiple Source Files</h5>

<p>As an example, assume that the definition of our <code class="language-plaintext highlighter-rouge">fact</code> function is in a file named <code class="language-plaintext highlighter-rouge">fact.cc</code> and its declaration is in a header file named <code class="language-plaintext highlighter-rouge">Chapter6.h</code>. Our <code class="language-plaintext highlighter-rouge">fact.cc</code> file, like any file that uses these functions, will include the <code class="language-plaintext highlighter-rouge">Chapter6.h</code> header. We’ll store a <code class="language-plaintext highlighter-rouge">main</code> function that calls <code class="language-plaintext highlighter-rouge">fact</code> in a second file named <code class="language-plaintext highlighter-rouge">factMain.cc</code>.</p>

<p>To produce an executable file, we must tell the compiler where to find all of the code we use. We might compile these files as follows:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>CC factMain.cc fact.cc <span class="c"># generates factMain.exe or a.out</span>
<span class="nv">$ </span>CC factMain.cc fact.cc <span class="nt">-o</span> main <span class="c"># generates main or main.exe</span>
</code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">CC</code> is the name of our compiler, <code class="language-plaintext highlighter-rouge">$</code> is our system prompt, and <code class="language-plaintext highlighter-rouge">#</code> begins a command-line comment.</p>

<p>If we have changed only one of our source files, we’d like to recompile only the file that actually changed. Most compilers provide a way to separately compile each file. This process usually yields a file with the <code class="language-plaintext highlighter-rouge">.obj</code> (Windows) or <code class="language-plaintext highlighter-rouge">.o</code> (UNIX) file extension, indicating that the file contains <strong>object code</strong>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>CC <span class="nt">-c</span> factMain.cc <span class="c"># generates factMain.o</span>
<span class="nv">$ </span>CC <span class="nt">-c</span> fact.cc <span class="c"># generates fact.o</span>
<span class="nv">$ </span>CC factMain.o fact.o <span class="c"># generates factMain.exe or a.out</span>
<span class="nv">$ </span>CC factMain.o fact.o <span class="nt">-o</span> main <span class="c"># generates main or main.exe</span>
</code></pre></div></div>

<h3 id="62-argument-passing">6.2 Argument Passing</h3>

<p>As we’ve seen, each time we call a function, its parameters are created and initialized by the arguments passed in the call.</p>

<p>Note: Parameter initialization works the same way as variable initialization.</p>

<p>As with any other variable, the type of a parameter determines the interaction between the parameter and its argument. If the parameter is a reference (§ 2.3.1, p. 50), then the parameter is bound to its argument. Otherwise, the argument’s value is copied. When a parameter is a reference, we say that its corresponding argument is “passed by reference” or that the function is “called by reference”.</p>

<p>When the argument value is copied, the parameter and argument are independent objects. We say such arguments are “passed by value” or alternatively that the function is “called by value”.</p>

<h4 id="621-passing-arguments-by-value">6.2.1 Passing Arguments by Value</h4>

<p>When we initialize a nonreference type variable, the value of the initializer is copied. Changes made to the variable have no effect on the initializer.</p>

<p>Passing an argument by value works exactly the same way.</p>

<h5 id="pointer-parameters">Pointer Parameters</h5>

<p>Pointers (§ 2.3.2, p. 52) behave like any other nonreference type.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// function that takes a pointer and sets the pointed-to value to zero</span>
<span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// changes the value of the object to which ip points</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// changes only the local copy of ip; the argument is unchanged</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Best Practice: Programmers accustomed to programming in C often use pointer parameters to access objects outside a function. In C++, programmers generally use reference parameters instead.</p>

<h4 id="622-passing-arguments-by-reference">6.2.2 Passing Arguments by Reference</h4>

<p>Reference parameters are often used to allow a function to change the value of its arguments.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// function that sets the given object to 0</span>
<span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As with any other reference, a reference parameter is bound directly to the object from which it is initialized. We pass an object directly; there is no need to pass its address:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">reset</span><span class="p">(</span><span class="n">j</span><span class="p">);</span> <span class="c1">// j is passed by reference; the value in j is changed</span>
</code></pre></div></div>

<h5 id="using-references-to-avoid-copies">Using References to Avoid Copies</h5>

<p>It can be inefficient to copy objects of large class types or large containers. Moreover, some class types (including the IO types) cannot be copied.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compare the length of two strings</span>
<span class="kt">bool</span> <span class="nf">isShorter</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Best Practice: Reference parameters that are not changed inside a function should be references to <code class="language-plaintext highlighter-rouge">const</code>.</p>

<h5 id="using-reference-parameters-to-return-additional-information">Using Reference Parameters to Return Additional Information</h5>

<p>A function can return only a single value. Reference parameters let us effectively return multiple results.</p>

<h4 id="623-const-parameters-and-arguments">6.2.3 <code class="language-plaintext highlighter-rouge">const</code> Parameters and Arguments</h4>

<p>Just as in any other initialization, when we copy an argument to initialize a parameter, top-level <code class="language-plaintext highlighter-rouge">const</code>s (§ 2.4.3, p. 63) on parameters are ignored. We can pass either a <code class="language-plaintext highlighter-rouge">const</code> or a non<code class="language-plaintext highlighter-rouge">const</code> object to a parameter (<code class="language-plaintext highlighter-rouge">i</code> in the following code) that has a top-level <code class="language-plaintext highlighter-rouge">const</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">fcn</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* fcn can read but not write to i */</span> <span class="p">}</span>
</code></pre></div></div>

<p>In C++, we can define several different functions that have the same name. However, we can do so only if their parameter lists are sufficiently different, otherwise it’s an error. For example,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">fcn</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* fcn can read but not write to i */</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">fcn</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="c1">// error: redefines fcn(int)</span>
</code></pre></div></div>

<p>Because top-level <code class="language-plaintext highlighter-rouge">const</code>s are ignored, we can pass exactly the same types to either version of <code class="language-plaintext highlighter-rouge">fcn</code>. The second version of <code class="language-plaintext highlighter-rouge">fcn</code> is an error. Despite appearances, its parameter list doesn’t differ from the list in the first version of <code class="language-plaintext highlighter-rouge">fcn</code>.</p>

<h5 id="pointer-or-reference-parameters-and-const">Pointer or Reference Parameters and <code class="language-plaintext highlighter-rouge">const</code></h5>

<p>Remember that, we can initialize an object with a low-level <code class="language-plaintext highlighter-rouge">const</code> from a non<code class="language-plaintext highlighter-rouge">const</code> object but not vice versa (§ 2.4.1, p. 61; § 2.4.2, p. 62), and a plain reference must be initialized from an object of the same type (§ 2.3.1, p. 50).</p>

<p>Exactly the same initialization rules apply to parameter passing:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span> <span class="c1">// calls the version of reset that has an int* parameter</span>
<span class="n">reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="p">);</span> <span class="c1">// error: can't initialize an int* from a pointer to a const int object</span>
<span class="n">reset</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// calls the version of reset that has an int&amp; parameter</span>
<span class="n">reset</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">// error: can't bind a plain reference to the const object ci</span>
<span class="n">reset</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// error: can't bind a plain reference to a literal</span>
<span class="n">reset</span><span class="p">(</span><span class="n">ctr</span><span class="p">);</span> <span class="c1">// error: types don't match; ctr has an unsigned type</span>
<span class="c1">// ok: find_char (§ 6.2.2, p. 211) 's first parameter is a reference to const</span>
<span class="n">find_char</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">,</span> <span class="n">ctr</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="use-reference-to-const-when-possible">Use Reference to <code class="language-plaintext highlighter-rouge">const</code> When Possible</h5>

<p>As we’ve just seen, we cannot pass a <code class="language-plaintext highlighter-rouge">const</code> object, or a literal, or an object that requires conversion to a plain reference parameter.</p>

<h4 id="624-array-parameters">6.2.4 Array Parameters</h4>

<p>Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array (§ 3.5.1, p. 114), and when we use an array it is (usually) converted to a pointer (§ 3.5.3, p. 117). When we pass an array to a function, we are actually passing a pointer to the array’s first element, and the size of the array is irrelevant.</p>

<p>Regardless of appearances, these declarations are equivalent: Each declares a function with a single parameter of type <code class="language-plaintext highlighter-rouge">const int*</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">[]);</span> <span class="c1">// shows the intent that the function takes an array</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span> <span class="c1">// dimension for documentation purposes (at best)</span>
</code></pre></div></div>

<p>When the compiler checks a call to <code class="language-plaintext highlighter-rouge">print</code>, it checks only that the argument has type <code class="language-plaintext highlighter-rouge">const int*</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="n">print</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span> <span class="c1">// ok: &amp;i is int*</span>
<span class="n">print</span><span class="p">(</span><span class="n">j</span><span class="p">);</span> <span class="c1">// ok: j is converted to an int* that points to j[0]</span>
</code></pre></div></div>

<p>WARNING: As with any code that uses arrays, functions that take array parameters must ensure that all uses of the array stay within the array bounds.</p>

<p>Because arrays are passed as pointers, functions ordinarily don’t know the size of the array they are given. They must rely on additional information provided by the caller. There are three common techniques used to manage pointer parameters.</p>

<h5 id="using-a-marker-to-specify-the-extent-of-an-array">Using a Marker to Specify the Extent of an Array</h5>

<p>The first approach to manage array arguments requires the array itself to contain an end marker. For example, C-style strings (§ 3.5.4, p. 122) are stored in character arrays in which the last character of the string is followed by a null character.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="c1">// if cp is not a null pointer</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="p">)</span> <span class="c1">// so long as the character it points to is not a null character</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">;</span> <span class="c1">// print the character and advance the pointer</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This convention works less well with data, such as <code class="language-plaintext highlighter-rouge">int</code>s, where every value in the range is a legitimate value.</p>

<h5 id="using-the-standard-library-conventions">Using the Standard Library Conventions</h5>

<p>A second technique used to manage array arguments is to pass pointers to the first and one past the last element in the array.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">beg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// print every element starting at beg up to but not including end</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">beg</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">beg</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// print the current element and advance the pointer</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To call this function,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">j</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="n">print</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">j</span><span class="p">));</span> <span class="c1">// begin and end functions, see § 3.5.3 (p. 118)</span>
</code></pre></div></div>

<h5 id="explicitly-passing-a-size-parameter">Explicitly Passing a Size Parameter</h5>

<p>A third approach for array arguments, which is common in C programs and older C++ programs, is to define a second parameter that indicates the size of the array.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// const int ia[] is equivalent to const int* ia</span>
<span class="c1">// size is passed explicitly and used to control access to elements of ia</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">ia</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ia</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To call this function,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">j</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="n">print</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">end</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">begin</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
</code></pre></div></div>

<h5 id="array-parameters-and-const">Array Parameters and <code class="language-plaintext highlighter-rouge">const</code></h5>

<h5 id="array-reference-parameters">Array Reference Parameters</h5>

<p>We can define a parameter that is a reference to an array.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ok: parameter is a reference to an array; the dimension is part of the type</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">arr</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note: The parentheses around <code class="language-plaintext highlighter-rouge">&amp;arr</code> are necessary (§ 3.5.1, p. 114):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="c1">// error: declares arr as an array of references</span>
<span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">])</span> <span class="c1">// ok: arr is a reference to an array of ten ints</span>
</code></pre></div></div>

<p>The fact that the size is part of the type limits the usefulness of this version of <code class="language-plaintext highlighter-rouge">print</code>. We may call this function only for an array
of exactly ten <code class="language-plaintext highlighter-rouge">int</code>s:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">k</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">print</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span> <span class="c1">// error: argument is not an array of ten ints</span>
<span class="n">print</span><span class="p">(</span><span class="n">j</span><span class="p">);</span> <span class="c1">// error: argument is not an array of ten ints</span>
<span class="n">print</span><span class="p">(</span><span class="n">k</span><span class="p">);</span> <span class="c1">// ok: argument is an array of ten ints</span>
</code></pre></div></div>

<p>We’ll see in § 16.1.1 (p. 654) how we might write this function in a way that would allow us to pass a reference parameter to an array of any size.</p>

<h5 id="passing-a-multidimensional-array">Passing a Multidimensional Array</h5>

<p>A multidimensional array is passed as a pointer to its first sub-array.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// matrix points to the first element in an array whose elements are arrays of ten ints</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">matrix</span><span class="p">)[</span><span class="mi">10</span><span class="p">],</span> <span class="kt">int</span> <span class="n">rowSize</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre></div></div>

<p>declares <code class="language-plaintext highlighter-rouge">matrix</code> as a pointer to an array of ten <code class="language-plaintext highlighter-rouge">int</code>s.</p>

<p>Note: Again, the parentheses around <code class="language-plaintext highlighter-rouge">*matrix</code> are necessary:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">matrix</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// array of ten pointers</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">matrix</span><span class="p">)[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// pointer to an array of ten ints</span>
</code></pre></div></div>

<p>We can also define our function using array syntax. As usual, the compiler ignores the first dimension, so it is best not to include it:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// equivalent definition</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">matrix</span><span class="p">[][</span><span class="mi">10</span><span class="p">],</span> <span class="kt">int</span> <span class="n">rowSize</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre></div></div>

<p>declares matrix to be what looks like a two-dimensional array. In fact, it’s still a pointer to an array of ten <code class="language-plaintext highlighter-rouge">int</code>s.</p>

<h4 id="625-main-handling-command-line-options">6.2.5 <code class="language-plaintext highlighter-rouge">main</code>: Handling Command-Line Options</h4>

<p>We sometimes need to pass arguments to <code class="language-plaintext highlighter-rouge">main</code>. The most common use of arguments to <code class="language-plaintext highlighter-rouge">main</code> is to let the user specify a set of options to guide the operation of the program.</p>

<h4 id="626-functions-with-varying-parameters">6.2.6 Functions with Varying Parameters</h4>

<p>The new standard provides two primary ways to write a function that takes a varying number of arguments: If all the arguments have the same type, we can pass a library type named <code class="language-plaintext highlighter-rouge">initializer_list</code>. If the argument types vary, we can write a special kind of function, known as a variadic template, which we’ll cover in § 16.4 (p. 699).</p>

<h5 id="initializer_list-parameters"><code class="language-plaintext highlighter-rouge">initializer_list</code> Parameters</h5>

<p>An <code class="language-plaintext highlighter-rouge">initializer_list</code> is a library type that represents an array (§ 3.5, p. 113) of values of the specified type. This type is defined in the <code class="language-plaintext highlighter-rouge">initializer_list</code> header.</p>

<p>Like a <code class="language-plaintext highlighter-rouge">vector</code>, <code class="language-plaintext highlighter-rouge">initializer_list</code> is a template type (§ 3.3, p. 96). When we define an <code class="language-plaintext highlighter-rouge">initializer_list</code>, we must specify the type of the elements that the list will contain:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ls</span><span class="p">;</span> <span class="c1">// initializer_list of strings</span>
<span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">li</span><span class="p">;</span> <span class="c1">// initializer_list of ints</span>
</code></pre></div></div>

<p>Unlike vector, the elements in an <code class="language-plaintext highlighter-rouge">initializer_list</code> are always <code class="language-plaintext highlighter-rouge">const</code> values.</p>

<p>We can write our function to produce an error code and error messages from a varying number of arguments as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">error_msg</span><span class="p">(</span><span class="n">ErrCode</span> <span class="n">e</span><span class="p">,</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">msg</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">elem</span> <span class="o">:</span> <span class="n">il</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To call this function,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">expected</span> <span class="o">!=</span> <span class="n">actual</span><span class="p">)</span>
    <span class="n">error_msg</span><span class="p">(</span><span class="n">ErrCode</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span> <span class="p">{</span><span class="s">"functionX"</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">});</span>
<span class="k">else</span>
    <span class="n">error_msg</span><span class="p">(</span><span class="n">ErrCode</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">{</span><span class="s">"functionX"</span><span class="p">,</span> <span class="s">"okay"</span><span class="p">});</span>
</code></pre></div></div>

<h5 id="ellipsis-parameters">Ellipsis Parameters</h5>

<p>Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named <code class="language-plaintext highlighter-rouge">varargs</code>.</p>

<h3 id="63-return-types-and-the-return-statement">6.3 Return Types and the return Statement</h3>

<p>There are two forms of <code class="language-plaintext highlighter-rouge">return</code> statements:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span><span class="p">;</span> <span class="c1">// no return value</span>
<span class="k">return</span> <span class="n">expression</span><span class="p">;</span> <span class="c1">// return a value</span>
</code></pre></div></div>

<h4 id="631-functions-with-no-return-value">6.3.1 Functions with No Return Value</h4>

<p>A <code class="language-plaintext highlighter-rouge">return</code> with no value may be used only in a function that has a <code class="language-plaintext highlighter-rouge">return</code> type of <code class="language-plaintext highlighter-rouge">void</code>. Functions that return <code class="language-plaintext highlighter-rouge">void</code> are not required to contain a <code class="language-plaintext highlighter-rouge">return</code>; an implicit <code class="language-plaintext highlighter-rouge">return</code> takes place after the function’s last statement.</p>

<h4 id="632-functions-that-return-a-value">6.3.2 Functions That Return a Value</h4>

<p>Every return in a function with a return type other than <code class="language-plaintext highlighter-rouge">void</code> must return a value. The value returned must have the same type as the function return type, or it must have a type that can be implicitly converted (§ 4.11, p. 159) to that type.</p>

<h5 id="how-values-are-returned">How Values Are Returned</h5>

<p>Values are returned in exactly the same way as variables and parameters are initialized: The return value is used to initialize a temporary at the call site, and that temporary is the result of the function call.</p>

<p>If the return type is a nonreference type, the return value is copied to the call site.</p>

<h5 id="never-return-a-reference-or-pointer-to-a-local-object">Never Return a Reference or Pointer to a Local Object</h5>

<p>When a function completes, its storage is freed (§ 6.1.1, p. 204). After a function terminates, references to local objects refer to memory that is no longer valid, and pointers to local objects would point to a nonexistent object.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// disaster: both returns refer to memory that is no longer available</span>
<span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">manip</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">ret</span><span class="p">;</span>
    <span class="c1">// transform ret in some way</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">// WRONG: returning a reference to a local object!</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="s">"Empty"</span><span class="p">;</span> <span class="c1">// WRONG: "Empty" is a local temporary string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Tip: One good way to ensure that the return is safe is to ask: To what preexisting object is the reference referring?</p>

<h5 id="functions-that-return-class-types-and-the-call-operator">Functions That Return Class Types and the Call Operator</h5>

<h5 id="reference-returns-are-lvalues">Reference Returns Are Lvalues</h5>

<p>Calls to functions that return references are lvalues; other return types yield rvalues. We can assign to the result of a function that returns a reference to non<code class="language-plaintext highlighter-rouge">const</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">&amp;</span><span class="n">get_val</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">ix</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">str</span><span class="p">[</span><span class="n">ix</span><span class="p">];</span> <span class="c1">// get_val assumes the given index is valid</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">s</span><span class="p">(</span><span class="s">"a value"</span><span class="p">);</span>
    <span class="n">get_val</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span> <span class="c1">// changes s[0] to A</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="list-initializing-the-return-value">List Initializing the Return Value</h5>

<p>Under the new standard, functions can return a braced list of values.</p>

<p>As an example, the following function returns a <code class="language-plaintext highlighter-rouge">vector</code> that holds the error-message <code class="language-plaintext highlighter-rouge">string</code>s:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">process</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="c1">// expected and actual are strings</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">expected</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">{};</span> <span class="c1">// return an empty vector</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">expected</span> <span class="o">==</span> <span class="n">actual</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">"functionX"</span><span class="p">,</span> <span class="s">"okay"</span><span class="p">};</span> <span class="c1">// return list-initialized vector</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">"functionX"</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="return-from-main">Return from <code class="language-plaintext highlighter-rouge">main</code></h5>

<p>There is one exception to the rule that a function with a return type other than <code class="language-plaintext highlighter-rouge">void</code> must return a value: If control reaches the end of <code class="language-plaintext highlighter-rouge">main</code> and there is no <code class="language-plaintext highlighter-rouge">return</code>, then the compiler implicitly inserts a return of 0.</p>

<p>As we saw in § 1.1 (p. 2), the value returned from <code class="language-plaintext highlighter-rouge">main</code> is treated as a status indicator. A zero return indicates success; most other values indicate failure. A nonzero value has a machine-dependent meaning. To make return values machine independent, the <code class="language-plaintext highlighter-rouge">cstdlib</code> header defines two preprocessor variables (§ 2.3.2, p. 54) that we can use to indicate success or failure:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">some_failure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span> <span class="c1">// defined in cstdlib</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> <span class="c1">// defined in cstdlib</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Because these are preprocessor variables, we must not precede them with <code class="language-plaintext highlighter-rouge">std::</code>, nor may we mention them in using declarations.</p>

<h5 id="recursion">Recursion</h5>

<p>A function that calls itself, either directly or indirectly, is a recursive function.</p>

<p>There must always be a path through a recursive function that does not involve a recursive call; otherwise, the function will recurse “forever”, meaning that the function will continue to call itself until the program stack is exhausted.</p>

<p>Note: The <code class="language-plaintext highlighter-rouge">main</code> function may not call itself.</p>

<h4 id="633-returning-a-pointer-to-an-array">6.3.3 Returning a Pointer to an Array</h4>

<p>Because we cannot copy an array, a function cannot return an array. However, a function can return a pointer or a reference to an array (§ 3.5.1, p. 114).</p>

<h5 id="declaring-a-function-that-returns-a-pointer-to-an-array">Declaring a Function That Returns a Pointer to an Array</h5>

<p>Remember that</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// arr is an array of ten ints</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p1</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// p1 is an array of ten pointers</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p2</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// p2 points to an array of ten ints</span>
</code></pre></div></div>

<p>The form of a function that returns a pointer to an array is:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Type</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">(</span><span class="n">parameter_list</span><span class="p">))[</span><span class="n">dimension</span><span class="p">]</span>
</code></pre></div></div>

<p>As an example,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">))[</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div></div>

<p>We can use a type alias to simplify the declaration of <code class="language-plaintext highlighter-rouge">func</code> and make it more readable (§ 2.5.1, p. 67):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">int</span> <span class="n">arrT</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// arrT is a synonym for the type array of ten ints</span>
<span class="k">using</span> <span class="n">arrT</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// equivalent declaration of arrT; see § 2.5.1 (p. 68)</span>
<span class="n">arrT</span><span class="o">*</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// func returns a pointer to an array of ten ints</span>
</code></pre></div></div>

<h5 id="using-a-trailing-return-type">Using a Trailing Return Type</h5>

<p>Under the new standard, another way to simplify the declaration of <code class="language-plaintext highlighter-rouge">func</code> is by using a trailing return type.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// func takes an int argument and returns a pointer to an array of ten ints</span>
<span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div></div>

<h5 id="using-decltype">Using <code class="language-plaintext highlighter-rouge">decltype</code></h5>

<p>As another alternative, if we know the array(s) to which our function can return a pointer, we can use <code class="language-plaintext highlighter-rouge">decltype</code> to declare the return type.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">odd</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">even</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">};</span>
<span class="c1">// returns a pointer to an array of five int elements</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">odd</span><span class="p">)</span> <span class="o">*</span><span class="n">arrPtr</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">odd</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">even</span><span class="p">;</span> <span class="c1">// returns a pointer to the array</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="64-overloaded-functions">6.4 Overloaded Functions</h3>

<p>Functions that have the same name but different parameter lists and that appear in the same scope are overloaded. For example, in § 6.2.4 (p. 214) we defined several functions named <code class="language-plaintext highlighter-rouge">print</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">beg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">end</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">ia</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div>

<p>When we call these functions, the compiler can deduce which function we want based on the argument type we pass:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">j</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span>
<span class="n">print</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">);</span> <span class="c1">// calls print(const char*)</span>
<span class="n">print</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">end</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">begin</span><span class="p">(</span><span class="n">j</span><span class="p">));</span> <span class="c1">// calls print(const int*, size_t)</span>
<span class="n">print</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">j</span><span class="p">));</span> <span class="c1">// calls print(const int*, const int*)</span>
</code></pre></div></div>

<p>Note: The <code class="language-plaintext highlighter-rouge">main</code> function may not be overloaded.</p>

<h5 id="defining-overloaded-functions">Defining Overloaded Functions</h5>

<h5 id="determining-whether-two-parameter-types-differ">Determining Whether Two Parameter Types Differ</h5>

<h5 id="overloading-and-const-parameters">Overloading and <code class="language-plaintext highlighter-rouge">const</code> Parameters</h5>

<p>As we saw in § 6.2.3 (p. 212), a parameter that has a top-level <code class="language-plaintext highlighter-rouge">const</code> is indistinguishable from one without a top-level <code class="language-plaintext highlighter-rouge">const</code>, so we cannot overload based on whether the parameter is a top-level <code class="language-plaintext highlighter-rouge">const</code>.</p>

<p>On the other hand, we can overload based on whether the parameter is a reference (or pointer) to the <code class="language-plaintext highlighter-rouge">const</code> or non<code class="language-plaintext highlighter-rouge">const</code> version of a given type; such <code class="language-plaintext highlighter-rouge">const</code>s are low-level.</p>

<p>ADVICE: WHEN NOT TO OVERLOAD A FUNCTION NAME</p>

<p>We should only overload operations that actually do similar things.</p>

<h5 id="const_cast-and-overloading"><code class="language-plaintext highlighter-rouge">const_cast</code> and Overloading</h5>

<p>In § 4.11.3 (p. 163) we noted that <code class="language-plaintext highlighter-rouge">const_cast</code>s are most useful in the context of overloaded functions.</p>

<h5 id="calling-an-overloaded-function">Calling an Overloaded Function</h5>

<h4 id="641-overloading-and-scope">6.4.1 Overloading and Scope</h4>

<p>Note: In C++, name lookup happens before type checking.</p>

<h3 id="65-features-for-specialized-uses">6.5 Features for Specialized Uses</h3>

<h4 id="651-default-arguments">6.5.1 Default Arguments</h4>

<p>If a parameter has a default argument, all the parameters that follow it must also have default arguments.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">sz</span><span class="p">;</span> <span class="c1">// typedef see § 2.5.1 (p. 67)</span>
<span class="n">string</span> <span class="nf">screen</span><span class="p">(</span><span class="n">sz</span> <span class="n">ht</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="n">sz</span> <span class="n">wid</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="kt">char</span> <span class="n">backgrnd</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="calling-functions-with-default-arguments">Calling Functions with Default Arguments</h5>

<h5 id="default-argument-declarations">Default Argument Declarations</h5>

<p>Each parameter can have its default specified only once in a given scope. For example, given</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// no default for the height or width parameters</span>
<span class="n">string</span> <span class="nf">screen</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">char</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">);</span>
</code></pre></div></div>

<p>we cannot change an already declared default value:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">screen</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">char</span> <span class="o">=</span> <span class="sc">'*'</span><span class="p">);</span> <span class="c1">// error: redeclaration</span>
</code></pre></div></div>

<p>but we can add a default argument as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">screen</span><span class="p">(</span><span class="n">sz</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="kt">char</span><span class="p">);</span> <span class="c1">// ok: adds default arguments</span>
</code></pre></div></div>

<p>Best Practices: Default arguments ordinarily should be specified with the function declaration in an appropriate header.</p>

<h5 id="default-argument-initializers">Default Argument Initializers</h5>

<p>Local variables may not be used as a default argument.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// the declarations of wd, def, and ht must appear outside a function</span>
<span class="n">sz</span> <span class="n">wd</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">def</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">;</span>
<span class="n">sz</span> <span class="nf">ht</span><span class="p">();</span>
<span class="n">string</span> <span class="nf">screen</span><span class="p">(</span><span class="n">sz</span> <span class="o">=</span> <span class="n">ht</span><span class="p">(),</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">wd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">=</span> <span class="n">def</span><span class="p">);</span>
<span class="n">string</span> <span class="n">window</span> <span class="o">=</span> <span class="n">screen</span><span class="p">();</span> <span class="c1">// calls screen(ht(), 80, ' ')</span>

<span class="kt">void</span> <span class="nf">f2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">def</span> <span class="o">=</span> <span class="sc">'*'</span><span class="p">;</span> <span class="c1">// changes the value of a default argument</span>
    <span class="n">sz</span> <span class="n">wd</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// hides the outer definition of wd but does not change the default</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">screen</span><span class="p">();</span> <span class="c1">// calls screen(ht(), 80, '*')</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Inside <code class="language-plaintext highlighter-rouge">f2</code>, we declared a local variable that hides the outer <code class="language-plaintext highlighter-rouge">wd</code>. However, the local named <code class="language-plaintext highlighter-rouge">wd</code> is unrelated to the default argument passed to screen.</p>

<h4 id="652-inline-and-constexpr-functions">6.5.2 <code class="language-plaintext highlighter-rouge">inline</code> and <code class="language-plaintext highlighter-rouge">constexpr</code> Functions</h4>

<p>Calling a function is apt to be slower than evaluating the equivalent expression. On most machines, a function call does a lot of work: Registers are saved before the call and restored after the return; arguments may be copied; and the program branches to a new location.</p>

<h5 id="inline-functions-avoid-function-call-overhead"><code class="language-plaintext highlighter-rouge">inline</code> Functions Avoid Function Call Overhead</h5>

<p>A function specified as inline (usually) is expanded “in line” at each call. If <code class="language-plaintext highlighter-rouge">shorterString</code> were defined as <code class="language-plaintext highlighter-rouge">inline</code>,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// inline version: find the shorter of two strings</span>
<span class="kr">inline</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">shorterString</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">s2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>then this call</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shorterString</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>(probably) would be expanded during compilation into something like</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>The run-time overhead of making <code class="language-plaintext highlighter-rouge">shorterString</code> a function is thus removed.</p>

<p>Note: The <code class="language-plaintext highlighter-rouge">inline</code> specification is only a request to the compiler. The compiler may choose to ignore this request.</p>

<p>In general, the <code class="language-plaintext highlighter-rouge">inline</code> mechanism is meant to optimize small, straight-line functions that are called frequently. Many compilers will not inline a recursive function. A 75-line function will almost surely not be expanded inline.</p>

<h5 id="constexpr-functions"><code class="language-plaintext highlighter-rouge">constexpr</code> Functions</h5>

<p>A <code class="language-plaintext highlighter-rouge">constexpr</code> function is a function that can be used in a constant expression (§ 2.4.4, p. 65).</p>

<h5 id="put-inline-and-constexpr-functions-in-header-files">Put <code class="language-plaintext highlighter-rouge">inline</code> and <code class="language-plaintext highlighter-rouge">constexpr</code> Functions in Header Files</h5>

<h4 id="653-aids-for-debugging">6.5.3 Aids for Debugging</h4>

<p>C++ programmers sometimes use a technique similar to header guards (§ 2.6.3, p. 77) to conditionally execute debugging code. The debugging code is turned off when the application is completed and ready to ship. This approach uses two preprocessor facilities: <code class="language-plaintext highlighter-rouge">assert</code> and <code class="language-plaintext highlighter-rouge">NDEBUG</code>.</p>

<h5 id="the-assert-preprocessor-macro">The <code class="language-plaintext highlighter-rouge">assert</code> Preprocessor Macro</h5>

<p><code class="language-plaintext highlighter-rouge">assert</code> is a preprocessor macro. A preprocessor macro is a preprocessor variable that acts somewhat like an inline function.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assert</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
</code></pre></div></div>

<p>evaluates <code class="language-plaintext highlighter-rouge">expr</code> and if the expression is false (i.e., zero), then assert writes a message and terminates the program.</p>

<p>The <code class="language-plaintext highlighter-rouge">assert</code> macro is defined in the <code class="language-plaintext highlighter-rouge">cassert</code> header. As we’ve seen, preprocessor names are managed by the preprocessor not the compiler (§ 2.6. 3, p. 76). As a result, we use preprocessor names directly and do not provide a <code class="language-plaintext highlighter-rouge">using</code> declaration for them. That is, we refer to <code class="language-plaintext highlighter-rouge">assert</code>, not <code class="language-plaintext highlighter-rouge">std::assert</code>, and provide no <code class="language-plaintext highlighter-rouge">using</code> declaration for <code class="language-plaintext highlighter-rouge">assert</code>.</p>

<p>As with preprocessor variables, macro names must be unique within the program. We should avoid using macro names in our program.</p>

<h5 id="the-ndebug-preprocessor-variable">The <code class="language-plaintext highlighter-rouge">NDEBUG</code> Preprocessor Variable</h5>

<p>The behavior of <code class="language-plaintext highlighter-rouge">assert</code> depends on the status of a preprocessor variable named <code class="language-plaintext highlighter-rouge">NDEBUG</code>. If <code class="language-plaintext highlighter-rouge">NDEBUG</code> is defined, <code class="language-plaintext highlighter-rouge">assert</code> does nothing. By default, <code class="language-plaintext highlighter-rouge">NDEBUG</code> is not defined, so, by default, <code class="language-plaintext highlighter-rouge">assert</code> performs a run-time check.</p>

<p>We can “turn off” debugging by writing a <code class="language-plaintext highlighter-rouge">#define NDEBUG</code> at the beginning of the script. Alternatively, most compilers provide a command-line option that lets us define preprocessor variables:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>CC <span class="nt">-D</span> NDEBUG main.C <span class="c"># use /D with the Microsoft compiler</span>
</code></pre></div></div>

<p>In addition to using <code class="language-plaintext highlighter-rouge">assert</code>, we can write our own conditional debugging code using <code class="language-plaintext highlighter-rouge">NDEBUG</code>. If <code class="language-plaintext highlighter-rouge">NDEBUG</code> is not defined, the code between the <code class="language-plaintext highlighter-rouge">#ifndef</code> and the <code class="language-plaintext highlighter-rouge">#endif</code> is executed. If <code class="language-plaintext highlighter-rouge">NDEBUG</code> is defined, that code is ignored:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">ia</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// print the name of the function we are debugging</span>
    <span class="cp">#ifndef NDEBUG
</span>    <span class="c1">// _ _func_ _ is a local static defined by the compiler that holds the function's name</span>
    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">_</span> <span class="n">_func_</span> <span class="n">_</span> <span class="o">&lt;&lt;</span> <span class="s">": array size is "</span> <span class="o">&lt;&lt;</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="c1">// ...</span>
</code></pre></div></div>

<p>In addition to <code class="language-plaintext highlighter-rouge">_ _func_ _</code>, which the C++ compiler defines, the preprocessor defines four other names that can be useful in debugging:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">_ _FILE_ _</code> string literal containing the name of the file</li>
  <li><code class="language-plaintext highlighter-rouge">_ _LINE_ _</code> integer literal containing the current line number</li>
  <li><code class="language-plaintext highlighter-rouge">_ _TIME_ _</code> string literal containing the time the file was compiled</li>
  <li><code class="language-plaintext highlighter-rouge">_ _DATE_ _</code> string literal containing the date the file was compiled</li>
</ul>

<h3 id="66-function-matching">6.6 Function Matching</h3>

<h5 id="determining-the-candidate-and-viable-functions">Determining the Candidate and Viable Functions</h5>

<h5 id="finding-the-best-match-if-any">Finding the Best Match, If Any</h5>

<p>The closer the types of the argument and parameter are to each other, the better the match.</p>

<h5 id="function-matching-with-multiple-parameters">Function Matching with Multiple Parameters</h5>

<p>If after looking at each argument there is no single function that is preferable, then the call is in error. The compiler will complain that the call is ambiguous.</p>

<p>Best Practices: Casts should not be needed to call an overloaded function. The need for a cast suggests that the parameter sets are designed poorly.</p>

<h4 id="661-argument-type-conversions">6.6.1 Argument Type Conversions</h4>

<h5 id="matches-requiring-promotion-or-arithmetic-conversion">Matches Requiring Promotion or Arithmetic Conversion</h5>

<h5 id="function-matching-and-const-arguments">Function Matching and <code class="language-plaintext highlighter-rouge">const</code> Arguments</h5>

<h3 id="67-pointers-to-functions">6.7 Pointers to Functions</h3>

<p>A function pointer is a pointer that denotes a function rather than an object. Like any other pointer, a function pointer points to a particular type. A function’s type is determined by its return type and the types of its parameters. For example,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">lengthCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>
</code></pre></div></div>

<p>has type <code class="language-plaintext highlighter-rouge">bool(const string&amp;, const string&amp;)</code>. To declare a pointer that can point at this function, we declare a pointer in place of the function name:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pf points to a function returning bool that takes two const string references</span>
<span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">// uninitialized</span>
</code></pre></div></div>

<p>Starting from the name we are declaring, we see that <code class="language-plaintext highlighter-rouge">pf</code> is preceded by a <code class="language-plaintext highlighter-rouge">*</code>, so <code class="language-plaintext highlighter-rouge">pf</code> is a pointer. To the right is a parameter list, which means that <code class="language-plaintext highlighter-rouge">pf</code> points to a function. Looking left, we find that the type the function returns is <code class="language-plaintext highlighter-rouge">bool</code>.</p>

<h5 id="using-function-pointers">Using Function Pointers</h5>

<p>When we use the name of a function as a value, the function is automatically converted to a pointer.  For example, we can assign the address of <code class="language-plaintext highlighter-rouge">lengthCompare</code> to <code class="language-plaintext highlighter-rouge">pf</code> as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pf</span> <span class="o">=</span> <span class="n">lengthCompare</span><span class="p">;</span> <span class="c1">// pf now points to the function named lengthCompare</span>
<span class="n">pf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lengthCompare</span><span class="p">;</span> <span class="c1">// equivalent assignment: address-of operator is optional</span>
</code></pre></div></div>

<p>We can use a pointer to a function to call the function. We can do so directly—there is no need to dereference the pointer:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">pf</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"goodbye"</span><span class="p">);</span> <span class="c1">// calls lengthCompare</span>
<span class="kt">bool</span> <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"goodbye"</span><span class="p">);</span> <span class="c1">// equivalent call</span>
<span class="kt">bool</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">lengthCompare</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"goodbye"</span><span class="p">);</span> <span class="c1">// equivalent call</span>
</code></pre></div></div>

<p>There is no conversion between pointers to one function type and pointers to another function type. However, as usual, we can assign <code class="language-plaintext highlighter-rouge">nullptr</code> (§ 2.3.2, p. 53) or a zero-valued integer constant expression to a function pointer to indicate that the pointer does not point to any function:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="nf">sumLength</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">cstringCompare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<span class="n">pf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// ok: pf points to no function</span>
<span class="n">pf</span> <span class="o">=</span> <span class="n">sumLength</span><span class="p">;</span> <span class="c1">// error: return type differs</span>
<span class="n">pf</span> <span class="o">=</span> <span class="n">cstringCompare</span><span class="p">;</span> <span class="c1">// error: parameter types differ</span>
<span class="n">pf</span> <span class="o">=</span> <span class="n">lengthCompare</span><span class="p">;</span> <span class="c1">// ok: function and pointer types match exactly</span>
</code></pre></div></div>

<h5 id="pointers-to-overloaded-functions">Pointers to Overloaded Functions</h5>

<p>The compiler uses the type of the pointer to determine which overloaded function to use.</p>

<h5 id="function-pointer-parameters">Function Pointer Parameters</h5>

<p>Just as with arrays (§ 6.2.4, p. 214), we cannot define parameters of function type but can have a parameter that is a pointer to function. As with arrays, we can write a parameter that looks like a function type, but it will be treated as a pointer:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// third parameter is a function type and is automatically treated as a pointer to function</span>
<span class="kt">void</span> <span class="nf">useBigger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">pf</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">));</span>
<span class="c1">// equivalent declaration: explicitly define the parameter as a pointer to function</span>
<span class="kt">void</span> <span class="nf">useBigger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span> <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">));</span>
</code></pre></div></div>

<p>When we pass a function as an argument, we can do so directly. It will be automatically converted to a pointer:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// automatically converts the function lengthCompare to a pointer to function</span>
<span class="n">useBigger</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">lengthCompare</span><span class="p">);</span>
</code></pre></div></div>

<p>As we’ve just seen in the declaration of <code class="language-plaintext highlighter-rouge">useBigger</code>, writing function pointer types quickly gets tedious. Type aliases (§ 2.5.1, p. 67), along with <code class="language-plaintext highlighter-rouge">decltype</code> (§ 2.5.3, p. 70), let us simplify code that uses function pointers:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Func and Func2 have function type</span>
<span class="k">typedef</span> <span class="kt">bool</span> <span class="nf">Func</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">decltype</span><span class="p">(</span><span class="n">lengthCompare</span><span class="p">)</span> <span class="n">Func2</span><span class="p">;</span> <span class="c1">// equivalent type</span>
<span class="c1">// FuncP and FuncP2 have pointer to function type</span>
<span class="k">typedef</span> <span class="nf">bool</span><span class="p">(</span><span class="o">*</span><span class="n">FuncP</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">decltype</span><span class="p">(</span><span class="n">lengthCompare</span><span class="p">)</span> <span class="o">*</span><span class="n">FuncP2</span><span class="p">;</span> <span class="c1">// equivalent type</span>
</code></pre></div></div>

<p>It is important to note that <code class="language-plaintext highlighter-rouge">decltype</code> returns the function type; the automatic conversion to pointer is not done, so we must add the <code class="language-plaintext highlighter-rouge">*</code> if we want a pointer. We can redeclare <code class="language-plaintext highlighter-rouge">useBigger</code> using any of these types:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// equivalent declarations of useBigger using type aliases</span>
<span class="kt">void</span> <span class="nf">useBigger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Func</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">useBigger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">FuncP2</span><span class="p">);</span>
</code></pre></div></div>

<p>In the first case, the compiler will automatically convert the function type represented by <code class="language-plaintext highlighter-rouge">Func</code> to a pointer.</p>

<h5 id="returning-a-pointer-to-function">Returning a Pointer to Function</h5>

<p>As with arrays (§ 6.3.3, p. 228), we can’t return a function type but can return a pointer to a function type. Similarly, we must write the return type as a pointer type; the compiler will not automatically treat a function return type as the corresponding pointer type.</p>

<p>For example,</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// the return type of f1 is a pointer to a function that has type int(int)</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">))(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div></div>

<p>Reading this declaration from the inside out, we see that <code class="language-plaintext highlighter-rouge">f1</code> has a parameter list, so <code class="language-plaintext highlighter-rouge">f1</code> is a function. <code class="language-plaintext highlighter-rouge">f1</code> is preceded by a <code class="language-plaintext highlighter-rouge">*</code> so <code class="language-plaintext highlighter-rouge">f1</code> returns a pointer. The type of that pointer itself has a parameter list, so the pointer points to a function. That function takes an <code class="language-plaintext highlighter-rouge">int</code> parameter and returns an <code class="language-plaintext highlighter-rouge">int</code>.</p>

<p>Also as with array returns, we can simply the declaration by using a type alias:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">F</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// F is a function type, not a pointer</span>
<span class="k">using</span> <span class="n">PF</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// PF is a pointer type</span>

<span class="n">PF</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// ok: PF is a pointer to function; f1 returns a pointer to function</span>
<span class="n">F</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// error: F is a function type; f1 can't return a function</span>
<span class="n">F</span><span class="o">*</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// ok: explicitly specify that the return type is a pointer to function</span>
</code></pre></div></div>

<p>For completeness, it’s worth noting that we can simplify declarations of functions that return pointers to function by using a trailing return (§ 6.3.3, p. 229):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="using-auto-or-decltype-for-function-pointer-types">Using <code class="language-plaintext highlighter-rouge">auto</code> or <code class="language-plaintext highlighter-rouge">decltype</code> for Function Pointer Types</h5>

<p>If we know which function(s) we want to return, we can use <code class="language-plaintext highlighter-rouge">decltype</code> to simplify writing a function pointer return type.  For example, assume we have two functions, both of which return a <code class="language-plaintext highlighter-rouge">string::size_type</code> and have two <code class="language-plaintext highlighter-rouge">const string&amp;</code> parameters. We can write a third function that takes a <code class="language-plaintext highlighter-rouge">string</code> parameter and returns a pointer to one of these two functions as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="nf">sumLength</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="nf">largerLength</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="c1">// depending on the value of its string parameter,</span>
<span class="c1">// getFcn returns a pointer to sumLength or to largerLength</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">sumLength</span><span class="p">)</span> <span class="o">*</span><span class="n">getFcn</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="chapter-summary">Chapter Summary</h3>

<p>Functions are named units of computation. Every function has a return type, a name, a (possibly empty) list of parameters, and a function body.</p>

<p>In C++, functions may be overloaded: The same name may be used to define different functions as long as the number or types of the parameters in the functions differ. The compiler automatically figures out which function to call based on the arguments in a call. The process of selecting the right function from a set of overloaded functions is referred to as function matching.</p>

<h3 id="defined-terms">Defined Terms</h3>

<p>Almost all terms are important. Read p. 251~252 for detail.</p>

<p><br /></p>

<h2 id="references">References</h2>

<p>Lippman, Stanley B., Josée Lajoie, and Barbara E. Moo. <em>C++ Primer</em>. Addison-Wesley Professional, 2012.</p>


  </div>

  <br> </br>
  <p><font color="grey" size="4"> Comments </font></p>
  <HR color=#D1D0CE SIZE=10>

<div id="disqus_thread"></div>

<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://walkermao.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


                            

  
</div>

      </section>
    </main><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-178951885-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-178951885-1');
</script>

    
    <div id="back-top">
      <a href="javascript:void(0);" onclick="topFunction()" title="Back to top"> </a>
    </div>

  </body>
</html>

<script src = "/assets/js/scroll_into_view.js"></script>
<script src = "/assets/js/back_to_top.js"></script>