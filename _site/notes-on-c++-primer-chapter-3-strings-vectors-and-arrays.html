<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://kit.fontawesome.com/123ecac47c.js" crossorigin="anonymous"></script><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="shortcut icon" type="image/png" href="/assets/portfolio.png">
<title>Notes on "C++ Primer": Chapter 3. Strings, Vectors, and Arrays</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Notes on “C++ Primer”: Chapter 3. Strings, Vectors, and Arrays | Weikai’s blog.</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Notes on “C++ Primer”: Chapter 3. Strings, Vectors, and Arrays" />
<meta name="author" content="Weikai Mao" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chapter 3. Strings, Vectors, and Arrays" />
<meta property="og:description" content="Chapter 3. Strings, Vectors, and Arrays" />
<link rel="canonical" href="http://localhost:4000/notes-on-c++-primer-chapter-3-strings-vectors-and-arrays.html" />
<meta property="og:url" content="http://localhost:4000/notes-on-c++-primer-chapter-3-strings-vectors-and-arrays.html" />
<meta property="og:site_name" content="Weikai’s blog." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-03T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Notes on “C++ Primer”: Chapter 3. Strings, Vectors, and Arrays" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Weikai Mao"},"dateModified":"2022-05-03T00:00:00+08:00","datePublished":"2022-05-03T00:00:00+08:00","description":"Chapter 3. Strings, Vectors, and Arrays","headline":"Notes on “C++ Primer”: Chapter 3. Strings, Vectors, and Arrays","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/notes-on-c++-primer-chapter-3-strings-vectors-and-arrays.html"},"url":"http://localhost:4000/notes-on-c++-primer-chapter-3-strings-vectors-and-arrays.html"}</script>
<!-- End Jekyll SEO tag -->


<meta name="google-site-verification" content="wXp8C1QlYKCpKxfXyFfQXEv9l5fJvcOi53ofYmOcaSA" />
<meta name="msvalidate.01" content="97F0BB32D312B808156DE357EA8474D3" />
<meta name="yandex-verification" content="690106a82d8966ab" />

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[", "\\]"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno"
      }
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    


  







</head>
  <body>
    <main class="container">
      <section class="about">
        <a href="/" class="iconlink"> 
          <h3> 
            <i class="fas fa-home"></i> HOME 
          </h3> 
        </a>
        <a href="/"> <img src="/assets/portfolio.png" alt="Weikai Mao"></a>
        <h2 id="title"> Weikai Mao </h2>
        <p style="font-size:90%" class="tagline">maoweikai123@outlook.com</p>
        
        <ul class="social"><a href="https://github.com/WalkerMao">
              <li>
                <i class="fab fa-github"></i>
              </li>
            </a><a href="https://www.linkedin.com/in/weikai-mao-000249124">
              <li>
                <i class="fab fa-linkedin"></i>
              </li>
            </a><a href="/wechat-qr-code.html">
              <li>
                <i class="fab fa-weixin"></i>
              </li>
            </a></ul><h3 style="color:gray; font-weight:normal"> Categories: </h3>
            <ul class="post-categories" style="max-width:225px;">
              
                  <a class="post-link" href="/"> <li style="padding: 4px 8px;"> All </li> </a>
              
                  <a class="post-link" href="/categories/cs"> <li style="padding: 4px 8px;"> CS </li> </a>
              
                  <a class="post-link" href="/categories/cv"> <li style="padding: 4px 8px;"> CV </li> </a>
              
                  <a class="post-link" href="/categories/dl"> <li style="padding: 4px 8px;"> DL </li> </a>
              
                  <a class="post-link" href="/categories/fe"> <li style="padding: 4px 8px;"> FE </li> </a>
              
                  <a class="post-link" href="/categories/math"> <li style="padding: 4px 8px;"> Math </li> </a>
              
                  <a class="post-link" href="/categories/ml"> <li style="padding: 4px 8px;"> ML </li> </a>
              
                  <a class="post-link" href="/categories/nlp"> <li style="padding: 4px 8px;"> NLP </li> </a>
              
                  <a class="post-link" href="/categories/stat"> <li style="padding: 4px 8px;"> Stat </li> </a>
              
                  <a class="post-link" href="/categories/杂"> <li style="padding: 4px 8px;"> 杂 </li> </a>
              
            </ul><p>&copy; 2023 </p>

      </section>
      <section class="content">
        <div class="sidebar">
  <ul><li><a href="#chapter-3-strings-vectors-and-arrays">Chapter 3. Strings, Vectors, and Arrays</a><ul><li><a href="#31-namespace-using-declarations">3.1 Namespace <code class="language-plaintext highlighter-rouge">using</code> Declarations</a><ul><li><a href="#a-separate-using-declaration-is-required-for-each-name">A Separate <code class="language-plaintext highlighter-rouge">using</code> Declaration Is Required for Each Name</a></li><li><a href="#headers-should-not-include-using-declarations">Headers Should Not Include <code class="language-plaintext highlighter-rouge">using</code> Declarations</a></li><li><a href="#a-note-to-the-reader">A Note to the Reader</a></li></ul></li></ul></li><li><a href="#32-library-string-type">3.2 Library <code class="language-plaintext highlighter-rouge">string</code> Type</a><ul><li><a href="#321-defining-and-initializing-strings">3.2.1 Defining and Initializing strings</a><ul><li><a href="#direct-and-copy-forms-of-initialization">Direct and Copy Forms of Initialization</a></li></ul></li><li><a href="#322-operations-on-strings">3.2.2 Operations on <code class="language-plaintext highlighter-rouge">string</code>s</a><ul><li><a href="#reading-and-writing-strings">Reading and Writing <code class="language-plaintext highlighter-rouge">string</code>s</a></li><li><a href="#using-getline-to-read-an-entire-line">Using <code class="language-plaintext highlighter-rouge">getline</code> to Read an Entire Line</a></li><li><a href="#the-string-empty-and-size-operations">The <code class="language-plaintext highlighter-rouge">string</code> <code class="language-plaintext highlighter-rouge">empty</code> and <code class="language-plaintext highlighter-rouge">size</code> Operations</a></li><li><a href="#the-stringsize_type-type">The <code class="language-plaintext highlighter-rouge">string::size_type</code> Type</a></li><li><a href="#comparing-strings">Comparing <code class="language-plaintext highlighter-rouge">string</code>s</a></li><li><a href="#assignment-for-strings">Assignment for <code class="language-plaintext highlighter-rouge">string</code>s</a></li><li><a href="#adding-two-strings">Adding Two <code class="language-plaintext highlighter-rouge">string</code>s</a></li><li><a href="#adding-literals-and-strings">Adding Literals and <code class="language-plaintext highlighter-rouge">string</code>s</a></li></ul></li><li><a href="#323-dealing-with-the-characters-in-a-string">3.2.3 Dealing with the Characters in a <code class="language-plaintext highlighter-rouge">string</code></a><ul><li><a href="#processing-every-character-use-range-based-for">Processing Every Character? Use Range-Based for</a></li><li><a href="#using-a-range-for-to-change-the-characters-in-a-string">Using a Range <code class="language-plaintext highlighter-rouge">for</code> to Change the Characters in a <code class="language-plaintext highlighter-rouge">string</code></a></li><li><a href="#processing-only-some-characters">Processing Only Some Characters?</a></li><li><a href="#using-a-subscript-for-iteration">Using a Subscript for Iteration</a></li><li><a href="#using-a-subscript-for-random-access">Using a Subscript for Random Access</a></li></ul></li></ul></li><li><a href="#33-library-vector-type">3.3 Library <code class="language-plaintext highlighter-rouge">vector</code> Type</a><ul><li><a href="#331-defining-and-initializing-vectors">3.3.1 Defining and Initializing <code class="language-plaintext highlighter-rouge">vector</code>s</a><ul><li><a href="#list-initializing-a-vector">List Initializing a <code class="language-plaintext highlighter-rouge">vector</code></a></li><li><a href="#creating-a-specified-number-of-elements">Creating a Specified Number of Elements</a></li><li><a href="#value-initialization">Value Initialization</a></li><li><a href="#list-initializer-or-element-count">List Initializer or Element Count?</a></li></ul></li><li><a href="#332-adding-elements-to-a-vector">3.3.2 Adding Elements to a <code class="language-plaintext highlighter-rouge">vector</code></a><ul><li><a href="#programming-implications-of-adding-elements-to-a-vector">Programming Implications of Adding Elements to a <code class="language-plaintext highlighter-rouge">vector</code></a></li></ul></li><li><a href="#333-other-vector-operations">3.3.3 Other vector Operations</a><ul><li><a href="#computing-a-vector-index">Computing a <code class="language-plaintext highlighter-rouge">vector</code> Index</a></li><li><a href="#subscripting-does-not-add-elements">Subscripting Does Not Add Elements</a></li></ul></li></ul></li><li><a href="#34-introducing-iterators">3.4 Introducing Iterators</a><ul><li><a href="#341-using-iterators">3.4.1 Using Iterators</a><ul><li><a href="#iterator-operations">Iterator Operations</a></li><li><a href="#moving-iterators-from-one-element-to-another">Moving Iterators from One Element to Another</a></li><li><a href="#iterator-types">Iterator Types</a></li><li><a href="#the-begin-and-end-operations">The <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code> Operations</a></li><li><a href="#combining-dereference-and-member-access">Combining Dereference and Member Access</a></li><li><a href="#some-vector-operations-invalidate-iterators">Some <code class="language-plaintext highlighter-rouge">vector</code> Operations Invalidate Iterators</a></li></ul></li><li><a href="#342-iterator-arithmetic">3.4.2 Iterator Arithmetic</a><ul><li><a href="#arithmetic-operations-on-iterators">Arithmetic Operations on Iterators</a></li><li><a href="#using-iterator-arithmetic">Using Iterator Arithmetic</a></li></ul></li></ul></li><li><a href="#35-arrays">3.5 Arrays</a><ul><li><a href="#351-defining-and-initializing-built-in-arrays">3.5.1 Defining and Initializing Built-in Arrays</a><ul><li><a href="#explicitly-initializing-array-elements">Explicitly Initializing Array Elements</a></li><li><a href="#character-arrays-are-special">Character Arrays Are Special</a></li><li><a href="#no-copy-or-assignment">No Copy or Assignment</a></li><li><a href="#understanding-complicated-array-declarations">Understanding Complicated Array Declarations</a></li></ul></li><li><a href="#352-accessing-the-elements-of-an-array">3.5.2 Accessing the Elements of an Array</a></li><li><a href="#353-pointers-and-arrays">3.5.3 Pointers and Arrays</a><ul><li><a href="#pointers-are-iterators">Pointers Are Iterators</a></li><li><a href="#the-library-begin-and-end-functions">The Library <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code> Functions</a></li><li><a href="#pointer-arithmetic">Pointer Arithmetic</a></li><li><a href="#interaction-between-dereference-and-pointer-arithmetic">Interaction between Dereference and Pointer Arithmetic</a></li><li><a href="#subscripts-and-pointers">Subscripts and Pointers</a></li></ul></li><li><a href="#354-c-style-character-strings">3.5.4 C-Style Character Strings</a><ul><li><a href="#c-library-string-functions">C Library String Functions</a></li><li><a href="#comparing-strings-1">Comparing Strings</a></li><li><a href="#caller-is-responsible-for-size-of-a-destination-string">Caller Is Responsible for Size of a Destination String</a></li></ul></li><li><a href="#355-interfacing-to-older-code">3.5.5 Interfacing to Older Code</a><ul><li><a href="#mixing-library-strings-and-c-style-strings">Mixing Library <code class="language-plaintext highlighter-rouge">string</code>s and C-Style Strings</a></li><li><a href="#using-an-array-to-initialize-a-vector">Using an Array to Initialize a <code class="language-plaintext highlighter-rouge">vector</code></a></li></ul></li></ul></li><li><a href="#36-multidimensional-arrays">3.6 Multidimensional Arrays</a><ul><li><a href="#initializing-the-elements-of-a-multidimensional-array">Initializing the Elements of a Multidimensional Array</a></li><li><a href="#subscripting-a-multidimensional-array">Subscripting a Multidimensional Array</a></li><li><a href="#using-a-range-for-with-multidimensional-arrays">Using a Range for with Multidimensional Arrays</a></li><li><a href="#pointers-and-multidimensional-arrays">Pointers and Multidimensional Arrays</a></li><li><a href="#type-aliases-simplify-pointers-to-multidimensional-arrays">Type Aliases Simplify Pointers to Multidimensional Arrays</a></li></ul></li></ul></li><li><a href="#chapter-summary">Chapter Summary</a></li><li><a href="#defined-terms">Defined Terms</a></li></ul></li><li><a href="#references">References</a></li></ul>

</div><div class="post-container" id="viewpoint">
  <a class="post-link" href="/notes-on-c++-primer-chapter-3-strings-vectors-and-arrays.html">
    <h2 class="post-title">Notes on &quot;C++ Primer&quot;: Chapter 3. Strings, Vectors, and Arrays</h2>
  </a>
  <div class="post-meta">
    <div>
      <ul class="post-categories"><a class="post-link" href="/categories/cs"> <li>CS</li> </a></ul>
      <ul class="post-tags"><a class="post-link" href="/tags/c++"> <li>C++</li> </a></ul>
    </div>
    <div class="post-date">
      <i class="icon-calendar"></i>
      May 3, 2022
    </div>
  </div>
  <div style="line-height:77%;">
    <br>
  </div>
  <div class="post"><div class="toc">
        <ul><li><a href="#chapter-3-strings-vectors-and-arrays">Chapter 3. Strings, Vectors, and Arrays</a><ul><li><a href="#31-namespace-using-declarations">3.1 Namespace <code class="language-plaintext highlighter-rouge">using</code> Declarations</a><ul><li><a href="#a-separate-using-declaration-is-required-for-each-name">A Separate <code class="language-plaintext highlighter-rouge">using</code> Declaration Is Required for Each Name</a></li><li><a href="#headers-should-not-include-using-declarations">Headers Should Not Include <code class="language-plaintext highlighter-rouge">using</code> Declarations</a></li><li><a href="#a-note-to-the-reader">A Note to the Reader</a></li></ul></li></ul></li><li><a href="#32-library-string-type">3.2 Library <code class="language-plaintext highlighter-rouge">string</code> Type</a><ul><li><a href="#321-defining-and-initializing-strings">3.2.1 Defining and Initializing strings</a><ul><li><a href="#direct-and-copy-forms-of-initialization">Direct and Copy Forms of Initialization</a></li></ul></li><li><a href="#322-operations-on-strings">3.2.2 Operations on <code class="language-plaintext highlighter-rouge">string</code>s</a><ul><li><a href="#reading-and-writing-strings">Reading and Writing <code class="language-plaintext highlighter-rouge">string</code>s</a></li><li><a href="#using-getline-to-read-an-entire-line">Using <code class="language-plaintext highlighter-rouge">getline</code> to Read an Entire Line</a></li><li><a href="#the-string-empty-and-size-operations">The <code class="language-plaintext highlighter-rouge">string</code> <code class="language-plaintext highlighter-rouge">empty</code> and <code class="language-plaintext highlighter-rouge">size</code> Operations</a></li><li><a href="#the-stringsize_type-type">The <code class="language-plaintext highlighter-rouge">string::size_type</code> Type</a></li><li><a href="#comparing-strings">Comparing <code class="language-plaintext highlighter-rouge">string</code>s</a></li><li><a href="#assignment-for-strings">Assignment for <code class="language-plaintext highlighter-rouge">string</code>s</a></li><li><a href="#adding-two-strings">Adding Two <code class="language-plaintext highlighter-rouge">string</code>s</a></li><li><a href="#adding-literals-and-strings">Adding Literals and <code class="language-plaintext highlighter-rouge">string</code>s</a></li></ul></li><li><a href="#323-dealing-with-the-characters-in-a-string">3.2.3 Dealing with the Characters in a <code class="language-plaintext highlighter-rouge">string</code></a><ul><li><a href="#processing-every-character-use-range-based-for">Processing Every Character? Use Range-Based for</a></li><li><a href="#using-a-range-for-to-change-the-characters-in-a-string">Using a Range <code class="language-plaintext highlighter-rouge">for</code> to Change the Characters in a <code class="language-plaintext highlighter-rouge">string</code></a></li><li><a href="#processing-only-some-characters">Processing Only Some Characters?</a></li><li><a href="#using-a-subscript-for-iteration">Using a Subscript for Iteration</a></li><li><a href="#using-a-subscript-for-random-access">Using a Subscript for Random Access</a></li></ul></li></ul></li><li><a href="#33-library-vector-type">3.3 Library <code class="language-plaintext highlighter-rouge">vector</code> Type</a><ul><li><a href="#331-defining-and-initializing-vectors">3.3.1 Defining and Initializing <code class="language-plaintext highlighter-rouge">vector</code>s</a><ul><li><a href="#list-initializing-a-vector">List Initializing a <code class="language-plaintext highlighter-rouge">vector</code></a></li><li><a href="#creating-a-specified-number-of-elements">Creating a Specified Number of Elements</a></li><li><a href="#value-initialization">Value Initialization</a></li><li><a href="#list-initializer-or-element-count">List Initializer or Element Count?</a></li></ul></li><li><a href="#332-adding-elements-to-a-vector">3.3.2 Adding Elements to a <code class="language-plaintext highlighter-rouge">vector</code></a><ul><li><a href="#programming-implications-of-adding-elements-to-a-vector">Programming Implications of Adding Elements to a <code class="language-plaintext highlighter-rouge">vector</code></a></li></ul></li><li><a href="#333-other-vector-operations">3.3.3 Other vector Operations</a><ul><li><a href="#computing-a-vector-index">Computing a <code class="language-plaintext highlighter-rouge">vector</code> Index</a></li><li><a href="#subscripting-does-not-add-elements">Subscripting Does Not Add Elements</a></li></ul></li></ul></li><li><a href="#34-introducing-iterators">3.4 Introducing Iterators</a><ul><li><a href="#341-using-iterators">3.4.1 Using Iterators</a><ul><li><a href="#iterator-operations">Iterator Operations</a></li><li><a href="#moving-iterators-from-one-element-to-another">Moving Iterators from One Element to Another</a></li><li><a href="#iterator-types">Iterator Types</a></li><li><a href="#the-begin-and-end-operations">The <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code> Operations</a></li><li><a href="#combining-dereference-and-member-access">Combining Dereference and Member Access</a></li><li><a href="#some-vector-operations-invalidate-iterators">Some <code class="language-plaintext highlighter-rouge">vector</code> Operations Invalidate Iterators</a></li></ul></li><li><a href="#342-iterator-arithmetic">3.4.2 Iterator Arithmetic</a><ul><li><a href="#arithmetic-operations-on-iterators">Arithmetic Operations on Iterators</a></li><li><a href="#using-iterator-arithmetic">Using Iterator Arithmetic</a></li></ul></li></ul></li><li><a href="#35-arrays">3.5 Arrays</a><ul><li><a href="#351-defining-and-initializing-built-in-arrays">3.5.1 Defining and Initializing Built-in Arrays</a><ul><li><a href="#explicitly-initializing-array-elements">Explicitly Initializing Array Elements</a></li><li><a href="#character-arrays-are-special">Character Arrays Are Special</a></li><li><a href="#no-copy-or-assignment">No Copy or Assignment</a></li><li><a href="#understanding-complicated-array-declarations">Understanding Complicated Array Declarations</a></li></ul></li><li><a href="#352-accessing-the-elements-of-an-array">3.5.2 Accessing the Elements of an Array</a></li><li><a href="#353-pointers-and-arrays">3.5.3 Pointers and Arrays</a><ul><li><a href="#pointers-are-iterators">Pointers Are Iterators</a></li><li><a href="#the-library-begin-and-end-functions">The Library <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code> Functions</a></li><li><a href="#pointer-arithmetic">Pointer Arithmetic</a></li><li><a href="#interaction-between-dereference-and-pointer-arithmetic">Interaction between Dereference and Pointer Arithmetic</a></li><li><a href="#subscripts-and-pointers">Subscripts and Pointers</a></li></ul></li><li><a href="#354-c-style-character-strings">3.5.4 C-Style Character Strings</a><ul><li><a href="#c-library-string-functions">C Library String Functions</a></li><li><a href="#comparing-strings-1">Comparing Strings</a></li><li><a href="#caller-is-responsible-for-size-of-a-destination-string">Caller Is Responsible for Size of a Destination String</a></li></ul></li><li><a href="#355-interfacing-to-older-code">3.5.5 Interfacing to Older Code</a><ul><li><a href="#mixing-library-strings-and-c-style-strings">Mixing Library <code class="language-plaintext highlighter-rouge">string</code>s and C-Style Strings</a></li><li><a href="#using-an-array-to-initialize-a-vector">Using an Array to Initialize a <code class="language-plaintext highlighter-rouge">vector</code></a></li></ul></li></ul></li><li><a href="#36-multidimensional-arrays">3.6 Multidimensional Arrays</a><ul><li><a href="#initializing-the-elements-of-a-multidimensional-array">Initializing the Elements of a Multidimensional Array</a></li><li><a href="#subscripting-a-multidimensional-array">Subscripting a Multidimensional Array</a></li><li><a href="#using-a-range-for-with-multidimensional-arrays">Using a Range for with Multidimensional Arrays</a></li><li><a href="#pointers-and-multidimensional-arrays">Pointers and Multidimensional Arrays</a></li><li><a href="#type-aliases-simplify-pointers-to-multidimensional-arrays">Type Aliases Simplify Pointers to Multidimensional Arrays</a></li></ul></li></ul></li><li><a href="#chapter-summary">Chapter Summary</a></li><li><a href="#defined-terms">Defined Terms</a></li></ul></li><li><a href="#references">References</a></li></ul>

      </div>
      </br><h2 id="chapter-3-strings-vectors-and-arrays">Chapter 3. Strings, Vectors, and Arrays</h2>

<p>The built-in types that we covered in Chapter 2 are defined directly by the C++ language. These types represent facilities present in most computer hardware, such as numbers or characters.</p>

<p>The standard library defines a number of additional types (<code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">vector</code>, etc.) of a higher-level nature that computer hardware usually does not implement directly. Associated with <code class="language-plaintext highlighter-rouge">string</code> and <code class="language-plaintext highlighter-rouge">vector</code> are companion types known as <strong>iterators</strong>, which are used to access the characters in a <code class="language-plaintext highlighter-rouge">string</code> or the elements in a <code class="language-plaintext highlighter-rouge">vector</code>.</p>

<p>The built-in array type represents facilities of the hardware. As a result, arrays are less convenient to use than the library <code class="language-plaintext highlighter-rouge">string</code> and <code class="language-plaintext highlighter-rouge">vector</code> types.</p>

<h3 id="31-namespace-using-declarations">3.1 Namespace <code class="language-plaintext highlighter-rouge">using</code> Declarations</h3>

<p>A <code class="language-plaintext highlighter-rouge">using</code> declaration has the form</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span><span class="o">::</span><span class="n">name</span><span class="p">;</span>
</code></pre></div></div>

<p>Once the <code class="language-plaintext highlighter-rouge">using</code> declaration has been made, we can access <code class="language-plaintext highlighter-rouge">name</code> directly.</p>

<h5 id="a-separate-using-declaration-is-required-for-each-name">A Separate <code class="language-plaintext highlighter-rouge">using</code> Declaration Is Required for Each Name</h5>

<h5 id="headers-should-not-include-using-declarations">Headers Should Not Include <code class="language-plaintext highlighter-rouge">using</code> Declarations</h5>

<p>Code inside headers (§ 2.6.3, p. 76) ordinarily should not use <code class="language-plaintext highlighter-rouge">using</code> declarations. The reason is that the contents of a header are copied into the including program’s text. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts.</p>

<h5 id="a-note-to-the-reader">A Note to the Reader</h5>

<h3 id="32-library-string-type">3.2 Library <code class="language-plaintext highlighter-rouge">string</code> Type</h3>

<p><strong>A <code class="language-plaintext highlighter-rouge">string</code> is a variable-length sequence of characters.</strong> To use the <code class="language-plaintext highlighter-rouge">string</code> type, we must include the <code class="language-plaintext highlighter-rouge">string</code> header. <strong><code class="language-plaintext highlighter-rouge">&lt;string&gt;</code> is a header file in C++ <code class="language-plaintext highlighter-rouge">std</code> library, and <code class="language-plaintext highlighter-rouge">string</code> is defined in the <code class="language-plaintext highlighter-rouge">std</code> namespace.</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="321-defining-and-initializing-strings">3.2.1 Defining and Initializing strings</h4>

<p>Ways to initialize a <code class="language-plaintext highlighter-rouge">string</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="n">s1</span> <span class="c1">// default initialization, s1 is the empty string with no characters</span>

<span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span> <span class="c1">// s2 is a copy of s1; copy initialization</span>
<span class="n">string</span> <span class="n">s2</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="c1">// direct initialization</span>

<span class="n">string</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">"value"</span> <span class="c1">// s3 is a copy of the string literal, not including the null; copy initialization</span>
<span class="n">string</span> <span class="n">s3</span><span class="p">(</span><span class="s">"value"</span><span class="p">)</span> <span class="c1">// direct initialization</span>

<span class="n">string</span> <span class="n">s4</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">)</span> <span class="c1">// initialize s4 with 5 copies of the character 'c', s4 is "ccccc"; direct initialization</span>
</code></pre></div></div>

<h5 id="direct-and-copy-forms-of-initialization">Direct and Copy Forms of Initialization</h5>

<p>When we initialize a variable using <code class="language-plaintext highlighter-rouge">=</code>, we are asking the compiler to <strong>copy initialize</strong> the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the <code class="language-plaintext highlighter-rouge">=</code>, we use <strong>direct initialization</strong>.</p>

<h4 id="322-operations-on-strings">3.2.2 Operations on <code class="language-plaintext highlighter-rouge">string</code>s</h4>

<h5 id="reading-and-writing-strings">Reading and Writing <code class="language-plaintext highlighter-rouge">string</code>s</h5>

<h5 id="using-getline-to-read-an-entire-line">Using <code class="language-plaintext highlighter-rouge">getline</code> to Read an Entire Line</h5>

<h5 id="the-string-empty-and-size-operations">The <code class="language-plaintext highlighter-rouge">string</code> <code class="language-plaintext highlighter-rouge">empty</code> and <code class="language-plaintext highlighter-rouge">size</code> Operations</h5>

<div align="center">
<figure>
<img src="https://raw.githubusercontent.com/gaoxiangnumber1/NotesPhotos/master/Cpp/Cp/3-2.png" alt="img" style="zoom:60%;" />
</figure>
</div>

<h5 id="the-stringsize_type-type">The <code class="language-plaintext highlighter-rouge">string::size_type</code> Type</h5>

<p>The type of the value returned by <code class="language-plaintext highlighter-rouge">size</code> function is <code class="language-plaintext highlighter-rouge">string::size_type</code> but not <code class="language-plaintext highlighter-rouge">int</code> or <code class="language-plaintext highlighter-rouge">unsigned</code> (§ 2.1.1, p. 34). <code class="language-plaintext highlighter-rouge">string::size_type</code> is an unsigned type  (§ 2.1.1, p. 32) big enough to hold the size of any <code class="language-plaintext highlighter-rouge">string</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">len</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">len</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// equivalent to previous, len has type string::size_type</span>
</code></pre></div></div>

<p>Because size returns an unsigned type, it is essential to remember that expressions that mix <code class="language-plaintext highlighter-rouge">signed</code> and <code class="language-plaintext highlighter-rouge">unsigned</code> data can have surprising results (§ 2.1.2, p. 36). For example, if <code class="language-plaintext highlighter-rouge">n</code> is an <code class="language-plaintext highlighter-rouge">int</code> that holds a negative value, then <code class="language-plaintext highlighter-rouge">s.size() &lt; n</code> will almost surely evaluate as <code class="language-plaintext highlighter-rouge">true</code>, because the negative value in <code class="language-plaintext highlighter-rouge">n</code> will convert to a large unsigned value.</p>

<h5 id="comparing-strings">Comparing <code class="language-plaintext highlighter-rouge">string</code>s</h5>

<h5 id="assignment-for-strings">Assignment for <code class="language-plaintext highlighter-rouge">string</code>s</h5>

<h5 id="adding-two-strings">Adding Two <code class="language-plaintext highlighter-rouge">string</code>s</h5>

<h5 id="adding-literals-and-strings">Adding Literals and <code class="language-plaintext highlighter-rouge">string</code>s</h5>

<h4 id="323-dealing-with-the-characters-in-a-string">3.2.3 Dealing with the Characters in a <code class="language-plaintext highlighter-rouge">string</code></h4>

<h5 id="processing-every-character-use-range-based-for">Processing Every Character? Use Range-Based for</h5>

<p>The range <code class="language-plaintext highlighter-rouge">for</code>  statement iterates through the elements in a given sequence and performs some operation on each value in that sequence. The syntactic form is</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">declaration</span> <span class="o">:</span> <span class="n">expression</span><span class="p">)</span>
	<span class="n">statement</span>
</code></pre></div></div>

<p>where expression is an object of a type that represents a sequence. On each iteration, the variable in <code class="language-plaintext highlighter-rouge">declaration</code> is initialized from the value of the next element in expression.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">str</span><span class="p">(</span><span class="s">"some string"</span><span class="p">);</span>
<span class="c1">// print the characters in str one character to a line</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">c</span> <span class="o">:</span> <span class="n">str</span><span class="p">)</span> <span class="c1">// for every char in str</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// print the current character followed by a newline</span>
</code></pre></div></div>

<p>In this case <code class="language-plaintext highlighter-rouge">c</code> is of type <code class="language-plaintext highlighter-rouge">char</code>. On each iteration, the next character in <code class="language-plaintext highlighter-rouge">str</code> will be copied into <code class="language-plaintext highlighter-rouge">c</code>.</p>

<p>We can declare references to the characters in <code class="language-plaintext highlighter-rouge">str</code> to avoid copying them: <code class="language-plaintext highlighter-rouge">for (auto &amp;c : str)</code>. We can also declare constant references to the characters If we don’t need to edit them: <code class="language-plaintext highlighter-rouge">for (auto &amp;c : str)</code>.</p>

<h5 id="using-a-range-for-to-change-the-characters-in-a-string">Using a Range <code class="language-plaintext highlighter-rouge">for</code> to Change the Characters in a <code class="language-plaintext highlighter-rouge">string</code></h5>

<p>If we want to change the value of the characters in a <code class="language-plaintext highlighter-rouge">string</code>, we must define the loop variable as a reference type.</p>

<p>Converting a <code class="language-plaintext highlighter-rouge">string</code> to all uppercase letters:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">"Hello World!!!"</span><span class="p">);</span>
<span class="c1">// convert s to uppercase</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="p">)</span> <span class="c1">// for every char in s (note: c is a reference)</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">// c is a reference, so the assignment changes the char in s</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<h5 id="processing-only-some-characters">Processing Only Some Characters?</h5>

<p>The subscript operator (the <code class="language-plaintext highlighter-rouge">[]</code> operator) takes a <code class="language-plaintext highlighter-rouge">string::size_type</code> (§ 3.2.2, p. 88) value that denotes the position of the character we want to access. The subscript operator <code class="language-plaintext highlighter-rouge">[]</code> returns a reference to the character at the given position.</p>

<p>The reference to the last character is <code class="language-plaintext highlighter-rouge">s[s.size()-1]</code>.</p>

<p>Note: The result of using an index outside this range is undefined. By implication, subscripting an empty <code class="language-plaintext highlighter-rouge">string</code> is undefined.</p>

<p>The value in the subscript is referred to as “a subscript” or “an index”. If our index has a signed type, its value will be converted to the unsigned type that <code class="language-plaintext highlighter-rouge">string::size_type</code> represents (§ 2.1.2, p. 36).</p>

<h5 id="using-a-subscript-for-iteration">Using a Subscript for Iteration</h5>

<p>As a another example, we’ll change the first word in <code class="language-plaintext highlighter-rouge">s</code> to all uppercase:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// process characters in s until we run out of characters or we hit a whitespace</span>
<span class="k">for</span> <span class="p">(</span><span class="k">decltype</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
	<span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span> <span class="c1">// capitalize the current character</span>
</code></pre></div></div>

<p>CAUTION: SUBSCRIPTS ARE UNCHECKED</p>

<p>When we use a subscript, we must ensure that the subscript is in range. That is, the subscript must be <code class="language-plaintext highlighter-rouge">&gt;= 0</code> and <code class="language-plaintext highlighter-rouge">&lt;</code> the <code class="language-plaintext highlighter-rouge">size()</code> of the <code class="language-plaintext highlighter-rouge">string</code>.</p>

<p>WARNING: The library is not required to check the value of an subscript. The result of using an out-of-range subscript is undefined.</p>

<h5 id="using-a-subscript-for-random-access">Using a Subscript for Random Access</h5>

<h3 id="33-library-vector-type">3.3 Library <code class="language-plaintext highlighter-rouge">vector</code> Type</h3>

<p><strong>A vector is a collection of objects, all of which have the same type.</strong> Every object in the collection has an associated index, which gives access to that object. A vector is often referred to as a container because it “contains” other objects.</p>

<p>We must include the <code class="language-plaintext highlighter-rouge">&lt;vector&gt;</code> header to use a <code class="language-plaintext highlighter-rouge">vector</code>. In our examples, we also assume that an appropriate using declaration is made:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
</code></pre></div></div>

<p>A vector is a <strong>class template</strong>. C++ has both class and function templates.</p>

<p>Templates are not themselves functions or classes. Instead, they can be thought of as instructions to the compiler for generating classes or functions. <strong>The process that the compiler uses to create classes or functions from templates is called instantiation.</strong> When we use a template, we specify what kind of class or function we want the compiler to instantiate.</p>

<p>For a class template, we specify which class to instantiate by supplying additional information: We supply it inside a pair of angle brackets following the template’s name.</p>

<p>In the case of <code class="language-plaintext highlighter-rouge">vector</code>, the additional information we supply is the type of the objects the <code class="language-plaintext highlighter-rouge">vector</code> will hold:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">;</span> <span class="c1">// ivec holds objects of type int</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Sales_item</span><span class="o">&gt;</span> <span class="n">Sales_vec</span><span class="p">;</span> <span class="c1">// holds Sales_items</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">file</span><span class="p">;</span> <span class="c1">// vector whose elements are vectors</span>
</code></pre></div></div>

<p>Note: <code class="language-plaintext highlighter-rouge">vector</code> is a template, not a type. Types generated from <code class="language-plaintext highlighter-rouge">vector</code> must include the element type, for example, <code class="language-plaintext highlighter-rouge">vector&lt;int&gt;</code>.</p>

<p>Because references are not objects, we cannot have a <code class="language-plaintext highlighter-rouge">vector</code> of references.</p>

<h4 id="331-defining-and-initializing-vectors">3.3.1 Defining and Initializing <code class="language-plaintext highlighter-rouge">vector</code>s</h4>

<p>As with any class type, the <code class="language-plaintext highlighter-rouge">vector</code> template controls how we define and initialize <code class="language-plaintext highlighter-rouge">vector</code>s.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">svec</span><span class="p">;</span> <span class="c1">// default initialization; svec has no elements</span>
</code></pre></div></div>

<p><strong>The most common way of using <code class="language-plaintext highlighter-rouge">vector</code>s is to define an initially empty <code class="language-plaintext highlighter-rouge">vector</code> to which elements are added as their values become known at run time.</strong></p>

<p>We can also supply initial value(s) for the element(s) when we define a <code class="language-plaintext highlighter-rouge">vector</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">;</span> <span class="c1">// initially empty</span>
<span class="c1">// give ivec some values</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec2</span><span class="p">(</span><span class="n">ivec</span><span class="p">);</span> <span class="c1">// copy elements of ivec into ivec2</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec3</span> <span class="o">=</span> <span class="n">ivec</span><span class="p">;</span> <span class="c1">// copy elements of ivec into ivec3</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">svec</span><span class="p">(</span><span class="n">ivec2</span><span class="p">);</span> <span class="c1">// error: svec holds strings, not ints</span>
</code></pre></div></div>

<h5 id="list-initializing-a-vector">List Initializing a <code class="language-plaintext highlighter-rouge">vector</code></h5>

<p>Under the new standard, we can list initialize (§ 2.2.1, p. 43) a vector from a list of zero or more initial element values enclosed in curly braces:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">articles</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"an"</span><span class="p">,</span> <span class="s">"the"</span><span class="p">};</span>
</code></pre></div></div>

<p>Or</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">articles</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"an"</span><span class="p">,</span> <span class="s">"the"</span><span class="p">};</span>
</code></pre></div></div>

<h5 id="creating-a-specified-number-of-elements">Creating a Specified Number of Elements</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// ten int elements, each initialized to -1</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">svec</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">"hi!"</span><span class="p">);</span> <span class="c1">// ten strings; each element is "hi!"</span>
</code></pre></div></div>

<h5 id="value-initialization">Value Initialization</h5>

<p>We can usually omit the value and supply only a size.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// ten elements, each initialized to 0</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">svec</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// ten elements, each an empty string</span>
</code></pre></div></div>

<div align="center">
<figure>
<img src="https://www.oreilly.com/library/view/c-primer-fifth/9780133053043/graphics/03tab04.jpg" alt="Image" style="zoom:100%;" />
<figcaption style="font-size: 80%;"> Table 3.4. Ways to Initialize a vector. (<a href="https://www.oreilly.com/library/view/c-primer-fifth/9780133053043/ch03lev2sec7.html">Source</a>) </figcaption>
</figure>
</div>

<h5 id="list-initializer-or-element-count">List Initializer or Element Count?</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// v1 has ten elements with value 0</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span> <span class="c1">// v2 has one element with value 10</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// v3 has ten elements with value 1</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v4</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// v4 has two elements with values 10 and 1</span>
</code></pre></div></div>

<p>When we use parentheses, we are saying that the values we supply are to be used to <em>construct</em> the object.</p>

<p>When we use curly braces, <code class="language-plaintext highlighter-rouge">{...}</code>, we’re saying that, if possible, we want to list initialize the object. That is, if there is a way to use the values inside the curly braces as a list of element initializers, the class will do so. Only if it is not possible to list initialize the object will the other ways to initialize the object be considered.</p>

<p>On the other hand, if we use braces and there is no way to use the initializers to list initialize the object, then those values will be used to construct the object.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v5</span><span class="p">{</span><span class="s">"hi"</span><span class="p">};</span> <span class="c1">// list initialization: v5 has one element</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v6</span><span class="p">(</span><span class="s">"hi"</span><span class="p">);</span> <span class="c1">// error: can't construct a vector from a string literal</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v7</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span> <span class="c1">// v7 has ten default initialized elements</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v8</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="s">"hi"</span><span class="p">};</span> <span class="c1">// v8 has ten elements with value "hi"</span>
</code></pre></div></div>

<h4 id="332-adding-elements-to-a-vector">3.3.2 Adding Elements to a <code class="language-plaintext highlighter-rouge">vector</code></h4>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">;</span> <span class="c1">// empty vector</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="n">v2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// append sequential integers to v2</span>
<span class="c1">// at end of loop v2 has 100 elements, values 0 ... 99</span>
</code></pre></div></div>

<p>Read the input, storing the values we read in the vector:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// read words from the standard input and store them as elements in a vector</span>
<span class="n">string</span> <span class="n">word</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">text</span><span class="p">;</span> <span class="c1">// empty vector</span>
<span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">text</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">word</span><span class="p">);</span> <span class="c1">// append word to text</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="programming-implications-of-adding-elements-to-a-vector">Programming Implications of Adding Elements to a <code class="language-plaintext highlighter-rouge">vector</code></h5>

<p>The fact that we can easily and efficiently add elements to a vector greatly simplifies many programming tasks.</p>

<p>We cannot use a range for if the body of the loop adds elements to the vector.</p>

<h4 id="333-other-vector-operations">3.3.3 Other vector Operations</h4>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="c1">// for each element in v (note: i is a reference)</span>
	<span class="n">i</span><span class="o">*</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// square the element value</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="c1">// for each element in v</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span> <span class="c1">// print the element</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>Note: To use <code class="language-plaintext highlighter-rouge">size_type</code>, we must name the type in which it is defined. A vector type always includes its element type (§ 3.3, p. 97):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="c1">// ok</span>
<span class="n">vector</span><span class="o">::</span><span class="n">size_type</span> <span class="c1">// error</span>
</code></pre></div></div>

<p>We can compare two <code class="language-plaintext highlighter-rouge">vector</code>s only if we can compare the elements in those <code class="language-plaintext highlighter-rouge">vector</code>s.</p>

<div align="center">
<figure>
<img src="https://www.oreilly.com/library/view/c-primer-fifth/9780133053043/graphics/03tab05.jpg" alt="Image" style="zoom:100%;" />
<figcaption style="font-size: 80%;"> Table 3.5: vector Operations (<a href="https://www.oreilly.com/library/view/c-primer-fifth/9780133053043/ch03lev2sec9.html">Source</a>) </figcaption>
</figure>
</div>

<h5 id="computing-a-vector-index">Computing a <code class="language-plaintext highlighter-rouge">vector</code> Index</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// count the number of grades by clusters of ten: 0--9, 10--19, ... 90--99, 100</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">scores</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 11 buckets, all initially 0</span>
<span class="kt">unsigned</span> <span class="n">grade</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grade</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// read the grades</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">grade</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">// handle only valid grades</span>
		<span class="o">++</span><span class="n">scores</span><span class="p">[</span><span class="n">grade</span><span class="o">/</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// increment the counter for the current cluster</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="subscripting-does-not-add-elements">Subscripting Does Not Add Elements</h5>

<h3 id="34-introducing-iterators">3.4 Introducing Iterators</h3>

<p><strong>Like pointers (§ 2.3.2, p. 52), iterators give us indirect access to an object.</strong></p>

<p>As with pointers, an iterator may be valid or invalid. A valid iterator either denotes an element or denotes a position one past the last element in a container. All other iterator values are invalid.</p>

<h4 id="341-using-iterators">3.4.1 Using Iterators</h4>

<p>Unlike pointers, we do not use the address-of operator to obtain an iterator. Instead, types that have iterators have members named <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code> that return iterators.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// the compiler determines the type of b and e; see § 2.5.2 (p. 68)</span>
<span class="c1">// b denotes the first element and e denotes one past the last element in v</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">e</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="c1">// b and e have the same type</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">begin</code> member returns an iterator that denotes the first element (or first character), if there is one.</p>

<p>The iterator returned by <code class="language-plaintext highlighter-rouge">end</code> member is often referred to as the off-the-end iterator or abbreviated as “the end iterator”. This iterator denotes a nonexistent element “off the end” of the container. It is used as a marker indicating when we have processed all the elements.</p>

<p>If the container is empty, the iterators returned by <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code> are equal—they are both off-the-end iterators.</p>

<p>In general, we do not know (or care about) the precise type that an iterator has. In this example, we used auto to define <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">e</code> (§ 2.5.2, p. 68).</p>

<h5 id="iterator-operations">Iterator Operations</h5>

<p>As with pointers, we can dereference an iterator to obtain the element denoted by an iterator. Also, like pointers, we may dereference only a valid iterator that denotes an element (§ 2.3.2, p. 53). Dereferencing an invalid iterator or an off-the-end iterator has undefined behavior.</p>

<div align="center">
<figure>
<img src="https://raw.githubusercontent.com/gaoxiangnumber1/NotesPhotos/master/Cpp/Cp/3-6.png" alt="img" style="zoom:60%;" />
</figure>
</div>

<p>As an example, we’ll rewrite the program from § 3.2.3 (p. 94) that capitalized the first character of a <code class="language-plaintext highlighter-rouge">string</code> using an iterator instead of a subscript:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">"some string"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// make sure s is not empty</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="c1">// it denotes the first character in s</span>
    <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span> <span class="c1">// make that character uppercase</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="moving-iterators-from-one-element-to-another">Moving Iterators from One Element to Another</h5>

<p>Iterators use the increment (<code class="language-plaintext highlighter-rouge">++</code>) operator (§ 1.4.1, p. 12) to move from one element to the next.</p>

<p>Note: Because the iterator returned from <code class="language-plaintext highlighter-rouge">end</code> does not denote an element, it may not be incremented or dereferenced.</p>

<p>Change the case of the first word in a <code class="language-plaintext highlighter-rouge">string</code> by using iterator an <code class="language-plaintext highlighter-rouge">it</code> and the increment operator <code class="language-plaintext highlighter-rouge">++</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// process characters in s until we run out of characters or we hit a whitespace</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span> <span class="c1">// capitalize the current character</span>
</code></pre></div></div>

<p>KEY CONCEPT: GENERIC PROGRAMMING</p>

<p>Only a few library types, <code class="language-plaintext highlighter-rouge">vector</code> and <code class="language-plaintext highlighter-rouge">string</code> being among them, have the subscript operator. Similarly, all of the library containers have iterators. Most of those iterators define the <code class="language-plaintext highlighter-rouge">==</code> and <code class="language-plaintext highlighter-rouge">!=</code> operators but do not have the <code class="language-plaintext highlighter-rouge">&lt;</code> operator.</p>

<h5 id="iterator-types">Iterator Types</h5>

<p>The library types that have iterators define types named <code class="language-plaintext highlighter-rouge">iterator</code> and <code class="language-plaintext highlighter-rouge">const_iterator</code> that represent actual iterator types:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span> <span class="c1">// it can read and write vector&lt;int&gt; elements</span>
<span class="n">string</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it2</span><span class="p">;</span> <span class="c1">// it2 can read and write characters in a string</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it3</span><span class="p">;</span> <span class="c1">// it3 can read but not write elements</span>
<span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it4</span><span class="p">;</span> <span class="c1">// it4 can read but not write characters</span>
</code></pre></div></div>

<p>If a <code class="language-plaintext highlighter-rouge">vector</code> or <code class="language-plaintext highlighter-rouge">string</code> is <code class="language-plaintext highlighter-rouge">const</code>, we may use only its <code class="language-plaintext highlighter-rouge">const_iterator</code> type.</p>

<h5 id="the-begin-and-end-operations">The <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code> Operations</h5>

<p>The type returned by <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code> depends on whether the object on which they operator is <code class="language-plaintext highlighter-rouge">const</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cv</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="c1">// it1 has type vector&lt;int&gt;::iterator</span>
<span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="c1">// it2 has type vector&lt;int&gt;::const_iterator</span>
</code></pre></div></div>

<p>For reasons we’ll explain in § 6.2.3 (p. 213), it is usually best to use a <code class="language-plaintext highlighter-rouge">const</code> type (such as <code class="language-plaintext highlighter-rouge">const_iterator</code>) when we need to read but do not need to write to an object. To let us ask specifically for the <code class="language-plaintext highlighter-rouge">const_iterator</code> type, the new standard introduced two new functions named <code class="language-plaintext highlighter-rouge">cbegin</code> and <code class="language-plaintext highlighter-rouge">cend</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">it3</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="c1">// it3 has type vector&lt;int&gt;::const_iterator</span>
</code></pre></div></div>

<h5 id="combining-dereference-and-member-access">Combining Dereference and Member Access</h5>

<p>Assuming <code class="language-plaintext highlighter-rouge">it</code> is an iterator into a <code class="language-plaintext highlighter-rouge">vector</code> of <code class="language-plaintext highlighter-rouge">string</code>s, we can check whether the <code class="language-plaintext highlighter-rouge">string</code> that <code class="language-plaintext highlighter-rouge">it</code> denotes is empty as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">).</span><span class="n">empty</span><span class="p">()</span>
</code></pre></div></div>

<p>To simplify expressions such as this one, the language defines the arrow operator (the <code class="language-plaintext highlighter-rouge">-&gt;</code> operator). The arrow operator combines dereference and member access into a single operation. That is, <code class="language-plaintext highlighter-rouge">it-&gt;mem</code> is a synonym for <code class="language-plaintext highlighter-rouge">(*it).mem</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// print each line in text up to the first blank line</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">text</span><span class="p">.</span><span class="n">cend</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<h5 id="some-vector-operations-invalidate-iterators">Some <code class="language-plaintext highlighter-rouge">vector</code> Operations Invalidate Iterators</h5>

<p>We cannot add elements to a <code class="language-plaintext highlighter-rouge">vector</code> inside a range <code class="language-plaintext highlighter-rouge">for</code> loop. We’ll explore how iterators become invalid in more detail in § 9.3.6 (p. 353).</p>

<h4 id="342-iterator-arithmetic">3.4.2 Iterator Arithmetic</h4>

<div align="center">
<figure>
<img src="https://raw.githubusercontent.com/gaoxiangnumber1/NotesPhotos/master/Cpp/Cp/3-7.png" alt="img" style="zoom:60%;" />
</figure>
</div>

<h5 id="arithmetic-operations-on-iterators">Arithmetic Operations on Iterators</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compute an iterator to the element closest to the midpoint of vi</span>
<span class="k">auto</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">)</span>
    <span class="c1">// process elements in the first half of vi</span>
</code></pre></div></div>

<p>We can also subtract two iterators to get the distance that refers to the amount by which we’d have to change one iterator to get the other. The result type is a signed integral type named <code class="language-plaintext highlighter-rouge">difference_type</code>.</p>

<h5 id="using-iterator-arithmetic">Using Iterator Arithmetic</h5>

<p>Do a binary search using iterators as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// text must be sorted</span>
<span class="c1">// beg and end will denote the range we're searching</span>
<span class="k">auto</span> <span class="n">beg</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">beg</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// original midpoint</span>
<span class="c1">// while there are still elements to look at and we haven't yet found sought</span>
<span class="k">while</span> <span class="p">(</span><span class="n">mid</span> <span class="o">!=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">mid</span> <span class="o">!=</span> <span class="n">sought</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sought</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">mid</span><span class="p">)</span> <span class="c1">// is the element we want in the first half?</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// if so, adjust the range to ignore the second half</span>
	<span class="k">else</span> <span class="c1">// the element we want is in the second half</span>
		<span class="n">beg</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// start looking with the element just after mid</span>
	<span class="n">mid</span> <span class="o">=</span> <span class="n">beg</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">beg</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// new midpoint</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="35-arrays">3.5 Arrays</h3>

<p>An array is a data structure that is similar to the library vector type (§ 3.3, p. 96) but offers a different trade-off between performance and flexibility. Like a vector, an array is a container of unnamed objects of a single type that we access by position. Unlike a vector, arrays have fixed size; we cannot add elements to an array. Because arrays have fixed size, they sometimes offer better run-time performance for specialized applications.</p>

<h4 id="351-defining-and-initializing-built-in-arrays">3.5.1 Defining and Initializing Built-in Arrays</h4>

<p>Arrays are a compound type (§ 2.3, p. 50). An array declarator has the form <code class="language-plaintext highlighter-rouge">a[d]</code>, where <code class="language-plaintext highlighter-rouge">a</code> is the name being defined and <code class="language-plaintext highlighter-rouge">d</code> is the dimension of (the number of elements in) the array. The dimension is part of the array’s type and must be known at compile time, which means that the dimension must be a constant expression (§ 2.4.4, p. 65):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// not a constant expression</span>
<span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// constant expression (§ 2.4.4, p. 66)</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// array of ten ints</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">parr</span><span class="p">[</span><span class="n">sz</span><span class="p">];</span> <span class="c1">// array of 42 pointers to int</span>
<span class="n">string</span> <span class="n">bad</span><span class="p">[</span><span class="n">cnt</span><span class="p">];</span> <span class="c1">// error: cnt is not a constant expression</span>
<span class="n">string</span> <span class="n">strs</span><span class="p">[</span><span class="n">get_size</span><span class="p">()];</span> <span class="c1">// ok if get_size is constexpr, error otherwise</span>
</code></pre></div></div>

<p>By default, the elements in an array are default initialized (§ 2.2.1, p. 43).</p>

<p>WARNING: As with variables of built-in type, a default-initialized array of built-in type that is defined inside a function will have undefined values.</p>

<p>As with vector, arrays hold objects. Thus, there are no arrays of references.</p>

<h5 id="explicitly-initializing-array-elements">Explicitly Initializing Array Elements</h5>

<p>We can list initialize (§ 3.3.1, p. 98) the elements in an array. When we do so, we can omit the dimension and let the compiler infers it from the number of initializers.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ia1</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// array of three ints with values 0, 1, 2</span>
<span class="kt">int</span> <span class="n">a2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// an array of dimension 3</span>
<span class="kt">int</span> <span class="n">a3</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// equivalent to a3[] = {0, 1, 2, 0, 0}</span>
<span class="n">string</span> <span class="n">a4</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"hi"</span><span class="p">,</span> <span class="s">"bye"</span><span class="p">};</span> <span class="c1">// same as a4[] = {"hi", "bye", ""}</span>
<span class="kt">int</span> <span class="n">a5</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// error: too many initializers</span>
</code></pre></div></div>

<h5 id="character-arrays-are-special">Character Arrays Are Special</h5>

<p>Character arrays have an additional form of initialization: We can initialize such arrays from a string literal (§ 2.1.3, p. 39). When we use this form of initialization, it is important to remember that string literals end with a null character. That null character is copied into the array along with the characters in the literal:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">a1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'C'</span><span class="p">,</span> <span class="sc">'+'</span><span class="p">,</span> <span class="sc">'+'</span><span class="p">};</span> <span class="c1">// list initialization, no null</span>
<span class="kt">char</span> <span class="n">a2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'C'</span><span class="p">,</span> <span class="sc">'+'</span><span class="p">,</span> <span class="sc">'+'</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">};</span> <span class="c1">// list initialization, explicit null</span>
<span class="kt">char</span> <span class="n">a3</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"C++"</span><span class="p">;</span> <span class="c1">// null terminator added automatically</span>
<span class="k">const</span> <span class="kt">char</span> <span class="n">a4</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Daniel"</span><span class="p">;</span> <span class="c1">// error: no space for the null!</span>
</code></pre></div></div>

<p>The dimension of <code class="language-plaintext highlighter-rouge">a1</code> is 3; the dimensions of <code class="language-plaintext highlighter-rouge">a2</code> and <code class="language-plaintext highlighter-rouge">a3</code> are both 4.</p>

<h5 id="no-copy-or-assignment">No Copy or Assignment</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// array of three ints</span>
<span class="kt">int</span> <span class="n">a2</span><span class="p">[]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// error: cannot initialize one array as a copy of another</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// error: cannot assign one array to another</span>
</code></pre></div></div>

<p>WARNING: Some compilers allow array assignment as a compiler extension. It is usually a good idea to avoid using nonstandard features. Programs that use such features, will not work with a different compiler.</p>

<h5 id="understanding-complicated-array-declarations">Understanding Complicated Array Declarations</h5>

<p>Defining a pointer or reference to an array is a bit complicated:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">ptrs</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// ptrs is an array of ten pointers to int</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">refs</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="cm">/* ? */</span><span class="p">;</span> <span class="c1">// error: no arrays of references</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">Parray</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// Parray points to an array of ten ints</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arrRef</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="c1">// arrRef refers to an array of ten ints</span>
</code></pre></div></div>

<p><strong>By default, type modifiers bind right to left.</strong> Reading the definition of <code class="language-plaintext highlighter-rouge">ptrs</code> from right to left (§ 2.3.3, p. 58) is easy: We see that we’re defining an array of size 10, named <code class="language-plaintext highlighter-rouge">ptrs</code>, that holds pointers to <code class="language-plaintext highlighter-rouge">int</code>.</p>

<p>As for the definition of <code class="language-plaintext highlighter-rouge">Parray</code>, reading from the inside out makes it easier to understand the type of <code class="language-plaintext highlighter-rouge">Parray</code>:  <code class="language-plaintext highlighter-rouge">(*Parray)</code> says that <code class="language-plaintext highlighter-rouge">Parray</code> is a pointer; <code class="language-plaintext highlighter-rouge">[10]</code> says <code class="language-plaintext highlighter-rouge">Parray</code> points to an array of size 10; <code class="language-plaintext highlighter-rouge">int</code> says the elements in that array are <code class="language-plaintext highlighter-rouge">int</code>s. Thus, <code class="language-plaintext highlighter-rouge">Parray</code> is a pointer to an array of 10 <code class="language-plaintext highlighter-rouge">int</code>s. Similarly, <code class="language-plaintext highlighter-rouge">arrRef</code> is a reference to an array of 10 <code class="language-plaintext highlighter-rouge">int</code>s.</p>

<p>Of course, there are no limits on how many type modifiers can be used:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arry</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptrs</span><span class="p">;</span> <span class="c1">// arry is a reference to an array of 10 pointers to int</span>
</code></pre></div></div>

<p>Reading this declaration from the inside out: <code class="language-plaintext highlighter-rouge">(&amp;arry)</code> says <code class="language-plaintext highlighter-rouge">arry</code> is a reference; <code class="language-plaintext highlighter-rouge">[10]</code> says <code class="language-plaintext highlighter-rouge">arry</code> points to an array of size 10; <code class="language-plaintext highlighter-rouge">int *</code> says the elements in the array are pointers to <code class="language-plaintext highlighter-rouge">int</code>.</p>

<p>Tip: It can be easier to understand array declarations by starting with the array’s name and reading them from the inside out.</p>

<h4 id="352-accessing-the-elements-of-an-array">3.5.2 Accessing the Elements of an Array</h4>

<p>As with the library <code class="language-plaintext highlighter-rouge">vector</code> and <code class="language-plaintext highlighter-rouge">string</code> types, we can use a range <code class="language-plaintext highlighter-rouge">for</code> or the subscript operator to access elements of an array.</p>

<p>When we use a variable to subscript an array, we normally should define that variable to have type <code class="language-plaintext highlighter-rouge">size_t</code>. <code class="language-plaintext highlighter-rouge">size_t</code> is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory.</p>

<p>Reimplement our grading program from § 3.3.3 (p. 104) to use an array:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// count the number of grades by clusters of ten: 0--9, 10--19, ... 90--99, 100</span>
<span class="kt">unsigned</span> <span class="n">scores</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// 11 buckets, all value initialized to 0</span>
<span class="kt">unsigned</span> <span class="n">grade</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grade</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">grade</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">)</span>
        <span class="o">++</span><span class="n">scores</span><span class="p">[</span><span class="n">grade</span><span class="o">/</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// increment the counter for the current cluster</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As in the case of <code class="language-plaintext highlighter-rouge">string</code> or <code class="language-plaintext highlighter-rouge">vector</code>, it is best to use a range <code class="language-plaintext highlighter-rouge">for</code> when we want to traverse the entire array.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">scores</span><span class="p">)</span> <span class="c1">// for each counter in scores</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span> <span class="c1">// print the value of that counter</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>As with <code class="language-plaintext highlighter-rouge">string</code> and <code class="language-plaintext highlighter-rouge">vector</code>, it is up to the programmer to ensure that the subscript value is in range. Nothing stops a program from stepping across an array boundary except careful attention to detail and thorough testing of the code. It is possible for programs to compile and execute yet still be fatally wrong.</p>

<p><strong>WARNING: The most common source of security problems are buffer overflow bugs.</strong> Such bugs occur when a program fails to check a subscript and mistakenly uses memory outside the range of an array or similar data structure.</p>

<h4 id="353-pointers-and-arrays">3.5.3 Pointers and Arrays</h4>

<p>In C++ pointers and arrays are closely intertwined. In particular, when we use an array, the compiler ordinarily converts the array to a pointer.</p>

<p>The elements in an array are objects. As with any other object, we can obtain a pointer to an array element by taking the address of that element:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"one"</span><span class="p">,</span> <span class="s">"two"</span><span class="p">,</span> <span class="s">"three"</span><span class="p">};</span> <span class="c1">// array of strings</span>
<span class="n">string</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// p points to the first element in nums</span>
</code></pre></div></div>

<p>However, arrays have a special property—in most places when we use an array, the compiler automatically substitutes a pointer to the first element:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span> <span class="c1">// equivalent to `string *p2 = &amp;nums[0]`</span>
</code></pre></div></div>

<p>Note: In most expressions, when we use an object of array type, we are really using a pointer to the first element in that array.</p>

<p>Operations on arrays are often really operations on pointers.</p>

<h5 id="pointers-are-iterators">Pointers Are Iterators</h5>

<p>Pointers that address elements in an array have additional operations beyond those we described in § 2.3.2 (p. 52). In particular, pointers to array elements support the same operations as iterators on vectors or strings (§ 3.4, p. 106). For example, we can use the increment operator to move from one element in an array to the next:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="c1">// p points to the first element in arr</span>
<span class="o">++</span><span class="n">p</span><span class="p">;</span> <span class="c1">// p points to arr[1]</span>
</code></pre></div></div>

<p>Just as we can use iterators to traverse the elements in a <code class="language-plaintext highlighter-rouge">vector</code>, we can use pointers to traverse the elements in an array.</p>

<p>We can obtain an off-the-end pointer by taking the address of the nonexistent element one past the last element of an array:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// pointer just past the last element in arr</span>
</code></pre></div></div>

<p>Like an off-the-end iterator (§ 3.4.1, p. 106), an off-the-end pointer does not point to an element. As a result, we may not dereference or increment an off-the-end pointer, and the only thing we can do with it is to take its address.</p>

<p>Using these pointers we can write a loop to print the elements in <code class="language-plaintext highlighter-rouge">arr</code> as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// print the elements in arr</span>
</code></pre></div></div>

<h5 id="the-library-begin-and-end-functions">The Library <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code> Functions</h5>

<p>Although we can compute an off-the-end pointer, doing so is error-prone. To make it easier and safer to use pointers, the new library includes two functions, named <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code>. These functions are defined in the iterator header. They take an argument that is an array:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">beg</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span> <span class="c1">// pointer to the first element in arr</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span> <span class="c1">// pointer one past the last element in arr</span>
</code></pre></div></div>

<p>Note: A pointer “one past” the end of a built-in array behaves the same way as the iterator returned by the end operation of a <code class="language-plaintext highlighter-rouge">vector</code>.</p>

<h5 id="pointer-arithmetic">Pointer Arithmetic</h5>

<p>Pointers that address array elements can use all the iterator operations listed in Table 3.6 (p. 107) and Table 3.7 (p. 111).</p>

<p>When we add (or subtract) an integral value to (or from) a pointer, the result is a new pointer. That new pointer points to the element the given number ahead of (or behind) the original pointer:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="c1">// equivalent to int *ip = &amp;arr[0]</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">ip2</span> <span class="o">=</span> <span class="n">ip</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// ip2 points to arr[4], the last element in arr</span>
<span class="c1">// ok: arr is converted to a pointer to its first element; p points one past the end of arr</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">sz</span><span class="p">;</span> <span class="c1">// use caution -- do not dereference!</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// error: arr has only 5 elements; p2 has undefined value</span>
</code></pre></div></div>

<p>Computing a pointer more than one past the last element is an error, although the compiler is unlikely to detect such errors.</p>

<p>As with iterators, subtracting two pointers gives us the distance between those pointers. The pointers must point to elements in the same array:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="n">begin</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span> <span class="c1">// n is 5, the number of elements in arr</span>
</code></pre></div></div>

<p>The result of subtracting two pointers is a library type named <code class="language-plaintext highlighter-rouge">ptrdiff_t</code>. Like <code class="language-plaintext highlighter-rouge">size_t</code>, the <code class="language-plaintext highlighter-rouge">ptrdiff_t</code> type is a machine-specific type and is defined in the <code class="language-plaintext highlighter-rouge">cstddef</code> header.</p>

<p>Traverse the elements in <code class="language-plaintext highlighter-rouge">arr</code> as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">sz</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// use *b</span>
    <span class="o">++</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It is worth noting that pointer arithmetic is also valid for null pointers (§ 2.3.2, p. 53) and for pointers that point to an object that is not an array.</p>

<h5 id="interaction-between-dereference-and-pointer-arithmetic">Interaction between Dereference and Pointer Arithmetic</h5>

<p>The result of adding an integral value to a pointer is itself a pointer.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ia</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">};</span> <span class="c1">// array with 5 elements of type int</span>
<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">ia</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// ok: initializes last to 8, the value of ia[4]</span>
<span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="o">*</span><span class="n">ia</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// ok: equivalent to ia[0] + 4</span>
</code></pre></div></div>

<h5 id="subscripts-and-pointers">Subscripts and Pointers</h5>

<p>In most places when we use the name of an array, we are really using a pointer to the first element in that array.</p>

<p>When we subscript an array, we are really subscripting a pointer to an element in that array:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ia</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// ia is converted to a pointer to the first element in ia; ia[2] fetches the element to which (ia + 2) points</span>
</code></pre></div></div>

<p>is equivalent to</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="c1">// p points to the first element in ia</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// equivalent to int i = ia[2]</span>
</code></pre></div></div>

<p>We can use the subscript operator on any pointer, as long as that pointer points to an element (or one past the last element) in an array:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ia</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// p points to the element indexed by 2</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// p[1] is equivalent to *(p + 1),</span>
<span class="c1">// p[1] is the same element as ia[3]</span>
<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// p[-2] is the same element as ia[0]</span>
</code></pre></div></div>

<p>This last example points out an important difference between arrays and library types such as <code class="language-plaintext highlighter-rouge">vector</code> and <code class="language-plaintext highlighter-rouge">string</code> that have subscript operators. The library types force the index used with a subscript to be an unsigned value. The built-in subscript operator does not. The index used with the built-in subscript operator can be a negative value. Of course, the resulting address must point to an element in (or one past the end of) the array to which the original pointer points.</p>

<h4 id="354-c-style-character-strings">3.5.4 C-Style Character Strings</h4>

<p>WARNING: Although C++ supports C-style strings, they should not be used by C++ programs. C-style strings are a surprisingly rich source of bugs and are the root cause of many security problems. They’re also harder to use!</p>

<h5 id="c-library-string-functions">C Library String Functions</h5>

<h5 id="comparing-strings-1">Comparing Strings</h5>

<h5 id="caller-is-responsible-for-size-of-a-destination-string">Caller Is Responsible for Size of a Destination String</h5>

<p>Tip: For most applications, in addition to being safer, it is also more efficient to use library strings rather than C-style strings.</p>

<h4 id="355-interfacing-to-older-code">3.5.5 Interfacing to Older Code</h4>

<p>Many C++ programs predate the standard library and do not use the <code class="language-plaintext highlighter-rouge">string</code> and <code class="language-plaintext highlighter-rouge">vector</code> types. Moreover, many C++ programs interface to programs written in C or other languages that cannot use the C++ library. Hence, programs written in modern C++ may have to interface to code that uses arrays and/or C-style character strings. The C++ library offers facilities to make the interface easier to manage.</p>

<h5 id="mixing-library-strings-and-c-style-strings">Mixing Library <code class="language-plaintext highlighter-rouge">string</code>s and C-Style Strings</h5>

<h5 id="using-an-array-to-initialize-a-vector">Using an Array to Initialize a <code class="language-plaintext highlighter-rouge">vector</code></h5>

<p>ADVICE: USE LIBRARY TYPES INSTEAD OF ARRAYS</p>

<p>Pointers and arrays are surprisingly error-prone. <strong>Modern C++ programs should use <code class="language-plaintext highlighter-rouge">vector</code>s and iterators instead of built-in arrays and pointers, and use <code class="language-plaintext highlighter-rouge">string</code>s rather than C-style array-based character strings.</strong></p>

<h3 id="36-multidimensional-arrays">3.6 Multidimensional Arrays</h3>

<p>Strictly speaking, there are no multidimensional arrays in C++. What are commonly referred to as multidimensional arrays are actually arrays of arrays.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// ia is an array of size 3; each element is an array of int s of size 4</span>
<span class="c1">// arr is an array of size 10; each element is a 20-element array whose elements are arrays of 30 int s</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">20</span><span class="p">][</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// initialize all elements to 0</span>
</code></pre></div></div>

<p>In a two-dimensional array, the first dimension is usually referred to as the row and the second as the column.</p>

<h5 id="initializing-the-elements-of-a-multidimensional-array">Initializing the Elements of a Multidimensional Array</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">// three elements; each element is an array of size 4</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="c1">// initializers for the row indexed by 0</span>
    <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span> <span class="c1">// row 1</span>
    <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">}</span> <span class="c1">// row 2</span>
<span class="p">};</span>
</code></pre></div></div>

<p>is equivalent to</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">};</span>
</code></pre></div></div>

<p>As is the case for single-dimension arrays, elements may be left out of the initializer list.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// initialize only the first element of each row; the remaining elements are initialized to 0</span>
<span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">8</span><span class="p">}</span> <span class="p">};</span>
<span class="c1">// explicitly initialize row 0; the remaining elements are initialized to 0</span>
<span class="kt">int</span> <span class="n">ix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
</code></pre></div></div>

<h5 id="subscripting-a-multidimensional-array">Subscripting a Multidimensional Array</h5>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// assigns the first element of arr to the last element in the last row of ia</span>
<span class="n">ia</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="c1">// defines row as a reference to an array of four ints; binds this reference to the second four-element array in ia</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">row</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></div></div>

<p>Use nested <code class="language-plaintext highlighter-rouge">for</code> loops to process the elements in a multidimensional array:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">rowCnt</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">colCnt</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="n">rowCnt</span><span class="p">][</span><span class="n">colCnt</span><span class="p">];</span> <span class="c1">// 12 uninitialized elements</span>
<span class="c1">// for each row</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">rowCnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for each column within the row</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">colCnt</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// assign the element's positional index as its value</span>
        <span class="n">ia</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">colCnt</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="using-a-range-for-with-multidimensional-arrays">Using a Range for with Multidimensional Arrays</h5>

<p>Under the new standard we can simplify the previous loop by using a range <code class="language-plaintext highlighter-rouge">for</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">row</span> <span class="o">:</span> <span class="n">ia</span><span class="p">)</span> <span class="c1">// for every element in the outer array</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">col</span> <span class="o">:</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for every element in the inner array</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span> <span class="c1">// give this element the next value</span>
        <span class="o">++</span><span class="n">cnt</span><span class="p">;</span> <span class="c1">// increment cnt</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first <code class="language-plaintext highlighter-rouge">for</code> iterates through the elements in <code class="language-plaintext highlighter-rouge">ia</code>. Those elements are arrays of size 4. Thus, the type of <code class="language-plaintext highlighter-rouge">row</code> is a reference to an array of four <code class="language-plaintext highlighter-rouge">int</code>s. The second <code class="language-plaintext highlighter-rouge">for</code> iterates through one of those 4-element arrays. Hence, <code class="language-plaintext highlighter-rouge">col</code> is <code class="language-plaintext highlighter-rouge">int&amp;</code>.</p>

<p>It is worth noting that we define <code class="language-plaintext highlighter-rouge">row</code> and <code class="language-plaintext highlighter-rouge">col</code> as references rather than <code class="language-plaintext highlighter-rouge">for (auto row : ia)</code> and <code class="language-plaintext highlighter-rouge">for (auto col : row)</code> to avoid copying them. This way is more efficient than copying when <code class="language-plaintext highlighter-rouge">row</code> and <code class="language-plaintext highlighter-rouge">col</code> is large.</p>

<p>The following loop does not write to the elements, yet we still define the control variable of the outer loop as a reference.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">row</span> <span class="o">:</span> <span class="n">ia</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">col</span> <span class="o">:</span> <span class="n">row</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">col</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>Note: To use a multidimensional array in a range for, the loop control variable for all but the innermost array must be references.</p>

<h5 id="pointers-and-multidimensional-arrays">Pointers and Multidimensional Arrays</h5>

<p>As with any array, when we use the name of a multidimensional array, it is automatically converted to a pointer to the first element in the array. For here the first element is the first inner array in the multidimensional array.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// array of size 3; each element is an array of int s of size 4</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="c1">// pointer to an array of four ints</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ia</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// p now points to the last element in ia</span>
</code></pre></div></div>

<p>Applying the strategy from § 3.5.1 (p. 115), we start by noting that (<code class="language-plaintext highlighter-rouge">*p</code>) says <code class="language-plaintext highlighter-rouge">p</code> is a pointer. Looking right, we see that the object to which <code class="language-plaintext highlighter-rouge">p</code> points has a dimension of size 4, and looking left that the element type is <code class="language-plaintext highlighter-rouge">int</code>. Hence, <code class="language-plaintext highlighter-rouge">p</code> is a pointer to an array of four <code class="language-plaintext highlighter-rouge">int</code>s.</p>

<p>Note: The parentheses in this declaration are essential:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">ip</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// array of pointers to int</span>
</code></pre></div></div>

<p>With the advent of the new standard, we can often avoid having to write the
type of a pointer into an array by using <code class="language-plaintext highlighter-rouge">auto</code> or <code class="language-plaintext highlighter-rouge">decltype</code> (§ 2.5.2, p. 68):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// print the value of each element in ia, with each inner array on its own line</span>
<span class="c1">// initialize p to point to the first array in ia</span>
<span class="c1">// the increment, ++p, moves p to point to the next row (i.e., the next element, the next array) in ia</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">ia</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// initialize q point to the first element of the array to which p points; this array is of four ints; thus q points to an int</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">q</span> <span class="o">!=</span> <span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">q</span> <span class="o">&lt;&lt;</span> <span class="err">''</span><span class="p">;</span> <span class="c1">// prints the int value to which q points</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can even more easily write this loop using the library <code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code> functions (§ 3.5.3, p. 118):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">ia</span><span class="p">);</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">ia</span><span class="p">);</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span> <span class="n">q</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">q</span> <span class="o">&lt;&lt;</span> <span class="err">''</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="type-aliases-simplify-pointers-to-multidimensional-arrays">Type Aliases Simplify Pointers to Multidimensional Arrays</h5>

<p>Define <code class="language-plaintext highlighter-rouge">int_array</code> as a name for the type “array of four <code class="language-plaintext highlighter-rouge">int</code>s”:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">int_array</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// new style type alias declaration; see § 2.5.1 (p. 68)</span>
</code></pre></div></div>

<p>Or equivalently:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">int</span> <span class="n">int_array</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// § 2.5.1 (p. 67)</span>
</code></pre></div></div>

<p>Then we can rewrite the first line as:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">int_array</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">ia</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
</code></pre></div></div>

<h3 id="chapter-summary">Chapter Summary</h3>

<p>Among the most important library types are <code class="language-plaintext highlighter-rouge">vector</code> and <code class="language-plaintext highlighter-rouge">string</code>. A <code class="language-plaintext highlighter-rouge">string</code> is a variable-length sequence of characters, and a <code class="language-plaintext highlighter-rouge">vector</code> is a container of objects of a single type.</p>

<p>Iterators allow indirect access to objects stored in a container. Iterators are used to access and navigate between the elements in <code class="language-plaintext highlighter-rouge">string</code>s and <code class="language-plaintext highlighter-rouge">vector</code>s.</p>

<p>Arrays and pointers to array elements provide low-level analogs to the <code class="language-plaintext highlighter-rouge">vector</code> and <code class="language-plaintext highlighter-rouge">string</code> libraries. In general, the library classes should be used in preference to low-level array and pointer alternatives built into the language.</p>

<h3 id="defined-terms">Defined Terms</h3>

<p><strong>buffer overflow</strong> Serious programming bug that results when we use an index that is out-of-range for a container, such as a <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">vector</code>, or an array.</p>

<p><strong>class template</strong> A blueprint from which specific class types can be created. To use a class template, we must specify additional information. For example, to define a <code class="language-plaintext highlighter-rouge">vector</code>, we specify the element type: <code class="language-plaintext highlighter-rouge">vector&lt;int&gt;</code> holds <code class="language-plaintext highlighter-rouge">int</code>s.</p>

<p><strong>container</strong> A type whose objects hold a collection of objects of a given type. vector is a container type.</p>

<p><strong>iterator</strong> A type used to access and navigate among the elements of a container.</p>

<p><strong>range for</strong> Control statement that iterates through a specified collection of values.</p>

<p><strong>string</strong> Library type that represents a sequence of characters.</p>

<p><strong>vector</strong> Library type that holds a collection of elements of a specified type.</p>

<p><br /></p>

<h2 id="references">References</h2>

<p>[1] Lippman, Stanley B., Josée Lajoie, and Barbara E. Moo. <em>C++ Primer</em>. Addison-Wesley Professional, 2012.</p>

<p>[2] Prata, Stephen. <em>C++ primer plus</em>. Addison-Wesley Professional, 2011.</p>

  </div>

  <br> </br>
  <p><font color="grey" size="4"> Comments </font></p>
  <HR color=#D1D0CE SIZE=10>

<div id="disqus_thread"></div>

<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://walkermao.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


                            

  
</div>

      </section>
    </main><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-178951885-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-178951885-1');
</script>

    
    <div id="back-top">
      <a href="javascript:void(0);" onclick="topFunction()" title="Back to top"> </a>
    </div>

  </body>
</html>

<script src = "/assets/js/scroll_into_view.js"></script>
<script src = "/assets/js/back_to_top.js"></script>