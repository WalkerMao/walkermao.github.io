<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://kit.fontawesome.com/123ecac47c.js" crossorigin="anonymous"></script><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="shortcut icon" type="image/png" href="/assets/portfolio.png">
<title>Sorting Algorithms</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Sorting Algorithms | Weikai’s blog.</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Sorting Algorithms" />
<meta name="author" content="Weikai Mao" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Here is a cheat sheet for big-O complexity of commonly used sorting algorithms:" />
<meta property="og:description" content="Here is a cheat sheet for big-O complexity of commonly used sorting algorithms:" />
<link rel="canonical" href="http://localhost:4000/sorting-algorithms.html" />
<meta property="og:url" content="http://localhost:4000/sorting-algorithms.html" />
<meta property="og:site_name" content="Weikai’s blog." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-25T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Sorting Algorithms" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Weikai Mao"},"dateModified":"2020-03-25T00:00:00+08:00","datePublished":"2020-03-25T00:00:00+08:00","description":"Here is a cheat sheet for big-O complexity of commonly used sorting algorithms:","headline":"Sorting Algorithms","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/sorting-algorithms.html"},"url":"http://localhost:4000/sorting-algorithms.html"}</script>
<!-- End Jekyll SEO tag -->


<meta name="google-site-verification" content="wXp8C1QlYKCpKxfXyFfQXEv9l5fJvcOi53ofYmOcaSA" />
<meta name="msvalidate.01" content="97F0BB32D312B808156DE357EA8474D3" />
<meta name="yandex-verification" content="690106a82d8966ab" />

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"] ],
        displayMath: [ ["$$","$$"], ["\\[", "\\]"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno"
      }
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    


  







</head>
  <body>
    <main class="container">
      <section class="about">
        <a href="/" class="iconlink"> 
          <h3> 
            <i class="fas fa-home"></i> HOME 
          </h3> 
        </a>
        <a href="/"> <img src="/assets/portfolio.png" alt="Weikai Mao"></a>
        <h2 id="title"> Weikai Mao </h2>
        <p style="font-size:90%" class="tagline">maoweikai123@outlook.com</p>
        
        <ul class="social"><a href="https://github.com/WalkerMao">
              <li>
                <i class="fab fa-github"></i>
              </li>
            </a><a href="https://www.linkedin.com/in/weikai-mao-000249124">
              <li>
                <i class="fab fa-linkedin"></i>
              </li>
            </a><a href="/wechat-qr-code.html">
              <li>
                <i class="fab fa-weixin"></i>
              </li>
            </a></ul><h3 style="color:gray; font-weight:normal"> Categories: </h3>
            <ul class="post-categories" style="max-width:225px;">
              
                  <a class="post-link" href="/"> <li style="padding: 4px 8px;"> All </li> </a>
              
                  <a class="post-link" href="/categories/cs"> <li style="padding: 4px 8px;"> CS </li> </a>
              
                  <a class="post-link" href="/categories/cv"> <li style="padding: 4px 8px;"> CV </li> </a>
              
                  <a class="post-link" href="/categories/dl"> <li style="padding: 4px 8px;"> DL </li> </a>
              
                  <a class="post-link" href="/categories/fe"> <li style="padding: 4px 8px;"> FE </li> </a>
              
                  <a class="post-link" href="/categories/math"> <li style="padding: 4px 8px;"> Math </li> </a>
              
                  <a class="post-link" href="/categories/ml"> <li style="padding: 4px 8px;"> ML </li> </a>
              
                  <a class="post-link" href="/categories/nlp"> <li style="padding: 4px 8px;"> NLP </li> </a>
              
                  <a class="post-link" href="/categories/stat"> <li style="padding: 4px 8px;"> Stat </li> </a>
              
                  <a class="post-link" href="/categories/杂"> <li style="padding: 4px 8px;"> 杂 </li> </a>
              
            </ul><p>&copy; 2023 </p>

      </section>
      <section class="content">
        <div class="sidebar">
  <ul><li><a href="#selection-sort-and-bubble-sort">Selection Sort and Bubble Sort</a><ul><li><a href="#selection-sort">Selection Sort</a></li><li><a href="#bubble-sort">Bubble Sort</a></li></ul></li><li><a href="#insertion-sort-and-shell-sort">Insertion Sort and Shell Sort</a><ul><li><a href="#insertion-sort">Insertion Sort</a></li><li><a href="#shell-sort">Shell Sort</a></li></ul></li><li><a href="#tree-sort-and-heap-sort">Tree Sort and Heap Sort</a><ul><li><a href="#tree-sort">Tree Sort</a></li><li><a href="#heap-sort">Heap Sort</a></li><li><a href="#comparison">Comparison</a></li></ul></li><li><a href="#merge-sort-and-quick-sort">Merge Sort and Quick Sort</a><ul><li><a href="#merge-sort">Merge Sort</a><ul><li><a href="#merge-sort-on-linked-list">Merge Sort on Linked List</a></li></ul></li><li><a href="#quick-sort">Quick Sort</a><ul><li><a href="#comparisons-between-heap-merge-and-quick-sort">Comparisons between Heap, Merge and Quick Sort</a></li><li><a href="#in-place-quick-sort-on-array-in-python">In-place Quick Sort on Array in Python</a></li><li><a href="#in-place-quick-sort-on-linked-list-in-python">In-place Quick Sort on Linked List in Python</a></li></ul></li></ul></li><li><a href="#non-comparison-sort-algorithm">Non-Comparison Sort Algorithm</a><ul><li><a href="#counting-sort">Counting Sort</a></li><li><a href="#radix-sort">Radix Sort</a></li><li><a href="#bucket-sort">Bucket Sort</a></li></ul></li></ul>

</div><div class="post-container" id="viewpoint">
  <a class="post-link" href="/sorting-algorithms.html">
    <h2 class="post-title">Sorting Algorithms</h2>
  </a>
  <div class="post-meta">
    <div>
      <ul class="post-categories"><a class="post-link" href="/categories/cs"> <li>CS</li> </a></ul>
      <ul class="post-tags"><a class="post-link" href="/tags/algorithms in cs"> <li>Algorithms in CS</li> </a></ul>
    </div>
    <div class="post-date">
      <i class="icon-calendar"></i>
      Mar 25, 2020
    </div>
  </div>
  <div style="line-height:77%;">
    <br>
  </div>
  <div class="post"><p>Here is a cheat sheet for big-O complexity of commonly used sorting algorithms:</p>

<table>
  <thead>
    <tr>
      <th>Algorithm</th>
      <th>Best Time</th>
      <th>Average Time</th>
      <th>Worst Time</th>
      <th>Space</th>
      <th>Stable?</th>
      <th>In-place?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Selection</td>
      <td>$n^2$</td>
      <td>$n^2$</td>
      <td>$n^2$</td>
      <td>$1$</td>
      <td>✓</td>
      <td>✓</td>
    </tr>
    <tr>
      <td>Bubble</td>
      <td>$n$</td>
      <td>$n^2$</td>
      <td>$n^2$</td>
      <td>$1$</td>
      <td>✓</td>
      <td>✓</td>
    </tr>
    <tr>
      <td>Insertion</td>
      <td>$n$</td>
      <td>$n^2$</td>
      <td>$n^2$</td>
      <td>$1$</td>
      <td>✓</td>
      <td>✓</td>
    </tr>
    <tr>
      <td>Shell</td>
      <td>$n\log_2 n$</td>
      <td>$n\log^2_2n$</td>
      <td>$n^2$</td>
      <td>$1$</td>
      <td>✗</td>
      <td>✓</td>
    </tr>
    <tr>
      <td>Tree</td>
      <td>$n\log_2 n$</td>
      <td>$n\log_2 n$</td>
      <td>$n^2$</td>
      <td>$n$</td>
      <td>✓</td>
      <td>✗</td>
    </tr>
    <tr>
      <td>Heap</td>
      <td>$n\log_2 n$</td>
      <td>$n\log_2 n$</td>
      <td>$n\log_2n$</td>
      <td>$1$</td>
      <td>✗</td>
      <td>✓</td>
    </tr>
    <tr>
      <td>Merge</td>
      <td>$n\log_2 n$</td>
      <td>$n\log_2 n$</td>
      <td>$n\log_2n$</td>
      <td>$n$</td>
      <td>✓</td>
      <td>✗</td>
    </tr>
    <tr>
      <td>Quick</td>
      <td>$n\log_2 n$</td>
      <td>$n\log_2 n$</td>
      <td>$n^2$</td>
      <td>$\log_2n$ or $n$</td>
      <td>✗</td>
      <td>✓</td>
    </tr>
    <tr>
      <td>Counting</td>
      <td>$n+k$</td>
      <td>$ n+k $</td>
      <td>$n+k$</td>
      <td>$n+k$</td>
      <td>✓</td>
      <td>✗</td>
    </tr>
    <tr>
      <td>Radix</td>
      <td>$l(n+c)$</td>
      <td>$l(n+c)$</td>
      <td>$l(n+c)$</td>
      <td>$n+c$</td>
      <td>✓</td>
      <td>✗</td>
    </tr>
    <tr>
      <td>Bucket</td>
      <td>$n+b$</td>
      <td>$n+b$</td>
      <td>$n^2$</td>
      <td>$n+b$</td>
      <td>✓</td>
      <td>✗</td>
    </tr>
  </tbody>
</table>

<p>Big-O asymptotic:</p>

<ul>
  <li>
    <p>Definition: $T(N) = O(f (N))$ if there are positive constants $c$ and $n_0$ such that \(T(N) \le c \cdot f(N)\) for all \(N \geq n_0\).</p>
  </li>
  <li>
    <p>Description: When $T(N) = O(f (N))$, we say that $T(N)$ is bounded above by $f(N)$ asymptotically (ignoring constant factors).</p>
  </li>
  <li>
    <p>Checking: When $T(N) = O(f (N))$, check if \(\lim_{N\to\infty} \frac{T(N)}{f(N)} \approx \text{Constant}\).</p>
  </li>
</ul>

<h2 id="selection-sort-and-bubble-sort">Selection Sort and Bubble Sort</h2>

<h3 id="selection-sort">Selection Sort</h3>

<p>The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning of the previous unsorted part.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">selectionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span> 
        <span class="c1"># Find the minimum element in remaining unsorted array 
</span>        <span class="n">min_idx</span> <span class="o">=</span> <span class="n">i</span> 
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span> 
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> 
                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">j</span> 
        <span class="c1"># Swap the found minimum element with the first element of the remaining unsorted array
</span>        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">min_idx</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="bubble-sort">Bubble Sort</h3>

<p>Bubble sort works by repeatedly swapping the adjacent elements if they are in wrong order.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span> 
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> 
        <span class="c1"># arr[:n+1] are remaining unsorted 
</span>        <span class="n">swapped</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span> 
            <span class="c1"># traverse the array from 0 to n, and swap if the element found is greater than the next element 
</span>            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> 
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> 
                <span class="n">swapped</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">swapped</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
            <span class="k">break</span>
</code></pre></div></div>

<div align="center">
<figure>
<img src="../../../pictures/bubble_sort.png" alt="BubbleSort" style="zoom: 100%;" />
<figcaption style="font-size: 80%;"> Bubble sort example. (<a href="https://eleni.blog/2019/06/09/sorting-in-go-using-bubble-sort/">Figure source</a>) </figcaption>
</figure>
</div>

<p>Note that \(O(n)\) is the best-case running time for bubble sort. By keeping track of the number of swaps it performs, if an array is already in sorted order, then bubble sort makes no swaps, the algorithm can terminate after one pass.</p>

<h2 id="insertion-sort-and-shell-sort">Insertion Sort and Shell Sort</h2>

<h3 id="insertion-sort">Insertion Sort</h3>

<p>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>

<p>Python code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insertionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span> 
        <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
        <span class="c1"># Move elements of arr[0..i-1], that are greater than key, to one position ahead their current position 
</span>        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">:</span> 
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> 
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span> 
</code></pre></div></div>

<div style="text-align: center">
<figure>
<img src="../../../pictures/insertion-sort.png" alt="InsertionSort" style="zoom: 70%;" />
<figcaption style="font-size: 80%;"> Insertion sort example. (<a href="https://www.geeksforgeeks.org/insertion-sort/">Figure source</a>) </figcaption>
</figure>
</div>
<h3 id="shell-sort">Shell Sort</h3>

<p>The shell sort, sometimes called the “diminishing increment sort”, improves on the insertion sort by breaking the original list into a number of smaller sublists, each of which is sorted using an insertion sort.</p>

<p>The unique way that these sublists are chosen is the key to the shell sort. Instead of breaking the list into sublists of contiguous items, the shell sort creates the sublists by an increment (sometimes called the <strong>gap</strong>).</p>

<div style="text-align: center">
<figure>
<img src="../../../pictures/shellsort.jpg" alt="shellsort.jpg" style="zoom:70%;" />
<figcaption style="font-size: 80%;"> Shell sort example. (<a href="https://www.geeksforgeeks.org/shellsort/">Figure source</a>) </figcaption>
</figure>
</div>

<p>There are two advantages of Shell Sort over Insertion Sort.</p>

<ul>
  <li>When the swap occurs in a noncontiguous sublist, the swap moves the item over a greater distance within the overall array. Insertion Sort only moves the item one position at a time. This means that in Shell Sort, the items being swapped are more likely to be closer to its final position then Insertion Sort.</li>
  <li>Since the items are more likely to be closer to its final position, the array itself become partially sorted. Thus when the segment number equals one, and Shell Sort is performing basically the Insertion Sort, it will be able to work very fast, since Insertion Sort is fast when the array is almost in order.</li>
</ul>

<h2 id="tree-sort-and-heap-sort">Tree Sort and Heap Sort</h2>

<p>They are both comparison based sorting techniques based on binary search trees and heaps.</p>

<h3 id="tree-sort">Tree Sort</h3>

<p>Tree sort builds a binary search tree (BST) for the elements and then traverses the tree in-order so that the elements come out in sorted order. It is faster for nearly sorted array.</p>

<p>Pseudo code:</p>

<pre><code class="language-pseudocode">def treeSort(arr): 
	BST = buildBST(arr)
	return inOrderTraverse(BST)
</code></pre>

<h3 id="heap-sort">Heap Sort</h3>

<p>Heap sort first transforms the array into a heap (implemented as an array) in-place (time $O(n)$), then divides the array into a sorted and an unsorted region. We do the following steps iteratively (time $O(n\log_2n)$): 1. swap the first and last element in unsorted region; 2. shrink the unsorted region by merging the last element into the the sorted region. 3. re-heapify the shrunk unsorted region.</p>

<p>Pseudo code:</p>

<pre><code class="language-pseudocode">def heapSort(arr):
	buildHeap(arr) # in-place
	for i from len(arr)-1 to 1:
		swap(arr[0], arr[i])
		heapify(arr[:i])
</code></pre>

<div style="text-align: center">
<figure>
<img src="../../../pictures/heap-sort.png" alt="Heap sort" style="zoom:100%;" />
<figcaption style="font-size: 80%;"> Heap sort example. </figcaption>
</figure>
</div>

<p>The left part (in heap) of the array is unsorted and the right part (not in heap) is sorted. We swap the first and last element in the unsorted array, then the last element is  in the sorted array. Heap sort can be thought of as an improved selection sort.</p>

<h3 id="comparison">Comparison</h3>

<p>Heap sort is always preferable to tree sort in terms of either time or space:</p>

<ul>
  <li>Time: The heap sort tends to be faster, because the heap is a balanced tree and its operations always are $O(\log_2n)$, in a determistic way, not on average. With BST, depending on the approach for balancing, insertion and deletion tend to take more time than the heap, no matter which balancing approach is used.</li>
  <li>Space: The heaps can be implemented as an array since they are always complete binary trees, but BSTs cannot because they are not guaranteed to be complete binary trees.</li>
  <li>Stability: Tree sort is stable, but heapsort is not because operations on the heap can change the relative order of equal items.</li>
</ul>

<h2 id="merge-sort-and-quick-sort">Merge Sort and Quick Sort</h2>

<p>Both them employ the <strong>divide-and-conquer</strong> paradigm based on recursion. This paradigm breaks a problem into subproblems that are similar to the original problem, recursively solves the subproblems, and finally combines the solutions to the subproblems to solve the original problem.</p>

<h3 id="merge-sort">Merge Sort</h3>

<p>Divide the array into two sublists recursively and merge them.</p>

<div style="text-align: center">
<figure>
<img src="../../../pictures/merge-sort.png" alt="Merge sort" style="zoom: 80%;" />
<figcaption style="font-size: 80%;"> Merge sort example. (<a href="https://www.geeksforgeeks.org/merge-sort/">Figure source</a>) </figcaption>
</figure>
</div>

<p>Space complexity analysis:</p>

<p>Suppose $n=16$, the space tree can be drawn as:</p>

<pre><code class="language-pseudocode">                     16                                 | 16
                    /  \                              
                   /    \
                  /      \
                 /        \
                8          8                            | 16
               / \        / \
              /   \      /   \
             4     4    4     4                         | 16
            / \   / \  / \   / \
           2   2 2   2 .......  2                       | 16
          / \  /\  ............ /\
         1  1  1 1 ............ 1 1                     | 16
</code></pre>

<p>The largest memory in recursion is:</p>

<pre><code class="language-pseudocode">                       16
                      /
                     8
                    /
                   4
                  /
                 2
               / \
              1   1
</code></pre>

<p>Thus, the space complexity is $O(3n)=O(n)$.</p>

<h4 id="merge-sort-on-linked-list">Merge Sort on Linked List</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">sortList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">head</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">head</span>
        <span class="n">slow</span><span class="p">,</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">slow</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">sortList</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">sortList</span><span class="p">(</span><span class="n">second</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">ListNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ListNode</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">l</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">l</span> <span class="ow">or</span> <span class="n">r</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">l</span>
        <span class="c1"># get the return node "head"
</span>        <span class="n">head</span> <span class="o">=</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">l</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">while</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nxt</span> <span class="o">=</span> <span class="n">pre</span><span class="p">.</span><span class="nb">next</span>
                <span class="n">pre</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="nb">next</span>
                <span class="n">r</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">nxt</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="p">.</span><span class="nb">next</span>
        <span class="c1"># l and r at least one is None
</span>        <span class="n">pre</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">l</span> <span class="ow">or</span> <span class="n">r</span>
        <span class="k">return</span> <span class="n">head</span>
</code></pre></div></div>

<h3 id="quick-sort">Quick Sort</h3>

<p>Recursively pick an element as pivot and partition the other elements by comparing them with the picked pivot.</p>

<div style="text-align: center">
<figure>
<img src="../../../pictures/quick-sort.png" alt="Quick sort" style="zoom:100%;" />
<figcaption style="font-size: 80%;"> Quick sort example. (<a href="https://www.geeksforgeeks.org/quick-sort/">Figure source</a>) </figcaption>
</figure>
</div>

<p>Best case: In the best case, each time we perform a partition we divide the list into two nearly equal pieces. The depth of the recurrence tree is $\log_2n$. The time in each level of the  recurrence tree is $O(n)$. Thus, in the best case, the time complexity is $O(n\log_2n)$ and the space complexity is $O(\log_2n)$.</p>

<p>Worst case: If the leftmost (or rightmost) element is chosen as pivot, the worst occurs when the array is <strong>already sorted</strong> in order or reverse order (a special case is that all elements are same). At this situation, every element will be a pivot, thus the time is \((n-1) + (n-2) + \cdots + 1 = \frac{n(n-1)}{2} = O(n^2)\), and the recurrence tree will be a right or left skewed tree thus the space is $O(n)$. The problem can be easily solved by choosing a random or middle index for the pivot. However, the worst case can still occurs when all elements are same.</p>

<h4 id="comparisons-between-heap-merge-and-quick-sort">Comparisons between Heap, Merge and Quick Sort</h4>

<p>Heap sort is the slowest. Heap sort may make more comparisons than optimal. Each siftUp operation makes two comparisons per level, so the comparison bound is approximately \(2n\log_2 n\). Heap Sort is more memory efficient and also in place. Merge sort is slightly faster than the heap sort for larger sets.</p>

<p>Quick sort is usually faster than most other $O(n\log_2n)$ comparison based algorithms in practice. The reasons are:</p>

<ul>
  <li><strong>Cache efficiency</strong>. Quick sort changes the array in-place, and it linearly scans the input and linearly partitions the input. Thus, it applies the principle of <a href="http://en.wikipedia.org/wiki/Locality_of_reference">locality of reference</a>. Cache benefits from multiple accesses to the same place in the memory, since only the first access needs to be actually taken from the memory, and the rest of the accesses are taken from cache, which is much faster than the access to memory. For heap sort, it needs to swap the elements that are usually not close to each other. If $n$ is large, the cache cannot store the heap array, thus we need to access the memory (RAM) frequently. Merge sort needs much more RAM accesses, since every accessory array you create is accessing the RAM again. Trees are even worse, since it is not in-place and two sequential accesses in a tree are not likely to be close to each other.</li>
  <li><strong>No unnecessary elements swaps</strong>. Swap is time consuming. With quick sort we don’t swap what is already ordered. The main competitors of quick sort are merge sort and heap sort. With heap sort, which is also in-place, even if all of your data is already ordered, we are going to swap all elements to order the array. With merge sort, which is not in-place, it’s even worse, since you are going to write all elements in another array and write it back in the original one, even if data is already ordered. However, it doesn’t mean heap sort is always faster than merge sort.</li>
</ul>

<p><a href="https://www.geeksforgeeks.org/quick-sort-vs-merge-sort/">Comparison between merge sort and quick sort</a></p>

<h4 id="in-place-quick-sort-on-array-in-python">In-place Quick Sort on Array in Python</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""returns the partition index"""</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="c1"># use arr[end] as pivot
</span>        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]:</span>
            <span class="c1"># swap to make the elements in arr[:j] be smaller than pivot
</span>            <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="c1"># now the elements in arr[:j] are smaller than arr[j],
</span>    <span class="c1"># and the elements in arr[j+1:] are larger than arr[j]
</span>    <span class="k">return</span> <span class="n">j</span>

<span class="c1"># another partition method
</span><span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="s">"""returns the partition index"""</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="c1"># left index i, and right index j
</span>    <span class="c1"># use arr[end] as pivot
</span>    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
        <span class="c1"># find i that makes arr[i] &gt;= pivot
</span>        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># find j that makes arr[j] &lt; pivot
</span>        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]:</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="c1"># swap left large element arr[i] and right small element arr[j]
</span>        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="c1"># now i == j, swap pivot and arr[j]
</span>    <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
    <span class="c1"># now the elements in arr[:j] are &lt; arr[j],
</span>    <span class="c1"># and the elements in arr[j+1:] are &gt;= arr[j]
</span>    <span class="k">return</span> <span class="n">j</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="s">"""in-place quicksort function"""</span>
    
    <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""recursive helper"""</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="c1"># partition index
</span>        <span class="n">helper</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># sort the left part arr[:j]
</span>        <span class="n">helper</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="c1"># sort the right part arr[j+1:]
</span>    
    <span class="n">helper</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="in-place-quick-sort-on-linked-list-in-python">In-place Quick Sort on Linked List in Python</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for singly-linked list.
</span><span class="k">class</span> <span class="nc">ListNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">sortList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">pivot</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">dummyLeft</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">dummyRight</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">left</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span> 
                <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">left</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">right</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        
        <span class="n">headLeft</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">sortList</span><span class="p">(</span><span class="n">dummyLeft</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">headLeft</span><span class="p">:</span>
            <span class="n">headLeft</span> <span class="o">=</span> <span class="n">pivot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tailLeft</span> <span class="o">=</span> <span class="n">headLeft</span>
            <span class="k">while</span> <span class="n">tailLeft</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span> 
                <span class="n">tailLeft</span> <span class="o">=</span> <span class="n">tailLeft</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">tailLeft</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">pivot</span>
        <span class="n">pivot</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">sortList</span><span class="p">(</span><span class="n">dummyRight</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span> 
        
        <span class="k">return</span> <span class="n">headLeft</span>
</code></pre></div></div>

<h2 id="non-comparison-sort-algorithm">Non-Comparison Sort Algorithm</h2>

<h3 id="counting-sort">Counting Sort</h3>

<p>Counting sort is usually used for sorting integers or characters. It is based on keys between a specific range. It works by counting the number of objects having distinct key values (kind of hashing). Then doing some arithmetic to calculate the position of each object in the output sequence.</p>

<div style="text-align: center">
<figure>
<img src="../../../pictures/count_sort_example.gif" alt="counting_sort" style="zoom:100%;" />
<figcaption style="font-size: 80%;"> Counting sort example. </figcaption>
</figure>
</div>

<p>Suppose the elements are in range from $1$ to $k$, thus there are $k$ keys.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Python code for counting sort.
</span><span class="k">def</span> <span class="nf">countingSort</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">:</span>
        <span class="n">count</span><span class="p">[</span><span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">count</span><span class="p">[</span><span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">output</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">)]]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<p>Time complexity of initializing the counting array of size $k$ is $O(k)$, and that of counting all elements is $O(n)$. Thus the time complexity of counting sort is $O(n+k)$. Space complexity is $O(k)$ since the size of the counting array is $k$.</p>

<h3 id="radix-sort">Radix Sort</h3>

<p>Counting sort is a linear time sorting algorithm that sort in $O(n+k)$ time when elements are in range from $1$ to $k$. However, if the elements are in a <strong>big range</strong>, for example, from $1$ to $n^2$, then $k=O(n^2)$, we cannot use counting sort because it will take $O(n^2)$ which is worse than comparison based sorting algorithms.</p>

<p>In this case, radix sort can sort such an array in linear time. The idea of Radix sort is to do digit by digit sort starting from least significant digit to most significant digit. Radix sort uses counting sort as a subroutine to sort.</p>

<div style="text-align: center">
<figure>
<img src="../../../pictures/radix-sort.png" alt="radix-sort" style="zoom:60%;" />
<figcaption style="font-size: 80%;"> Radix sort example. </figcaption>
</figure>
</div>

<p>Suppose there are $l$ digits(or characters) in each input integer(or string), and there are $c$ different digits(or characters), for example, $c=10$ for digits and $c=26$ for characters. Note that $c$ is the size of the count array in each counting sort of each pass, also $k=O(c^l)$.</p>

<p>In radix sort, we perform counting sort for $l$ passes, and each counting sort takes $O(n+c)$ time, thus the time complexity of radix sort is $O(l(n+c))$. The space complexity also comes from counting sort, which requires $O(n+c)$ space.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># use the bucket sort internally.
</span><span class="k">def</span> <span class="nf">radixSort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Convert nums list to reversed bit array list
</span>    <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="nb">bin</span><span class="p">(</span><span class="n">num</span><span class="p">)[</span><span class="mi">2</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">]</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">nums</span><span class="p">))):</span>
        <span class="n">nums0</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">'0'</span><span class="p">]</span>
        <span class="n">nums1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">'1'</span><span class="p">]</span>
        <span class="c1"># it will only have two buckets (0, 1) in radix sort.
</span>        <span class="n">nums</span> <span class="o">=</span> <span class="n">nums0</span> <span class="o">+</span> <span class="n">nums1</span>
    <span class="c1"># convert the number back to base 10 integer. 
</span>    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<h3 id="bucket-sort">Bucket Sort</h3>

<p>For counting sort, if the range of the elements is very big, then the size of the count array $k$ will be unaffordable large. As discussed before, radix sort can reduce the space. However, if the size of different element values is small, bucket sort is more suitable. For example, if the input array is $1,1,1,1000,1000,1000$, then the count array for counting sort is of size $1000$, and radix sort is also not that good since it does four passes. In bucket sort, we use buckets instead of count array. The number of buckets $b$ is usually much smaller than $k$.</p>

<p>Bucket sort works as follows:</p>

<ol>
  <li>Set up an array of initially empty “buckets”.</li>
  <li><strong>Scatter</strong>: Go over the original array, putting each object in its bucket.</li>
  <li>Sort each non-empty bucket using bucket sort or other sorting methods.</li>
  <li><strong>Gather</strong>: Visit the buckets in order and put all elements back into the original array.</li>
</ol>

<div style="text-align: center">
<figure>
<img src="../../../pictures/bucket-sort.png" alt="bucket-sort" style="zoom:60%;" />
<figcaption style="font-size: 80%;"> Bucket sort example. </figcaption>
</figure>
</div>

<p>Bucket sort is mainly useful when input is uniformly distributed over a range. The worst-case scenario occurs when all the elements are placed in a single bucket. The overall performance would then be dominated by the algorithm used to sort each bucket, which is typically $O(n^{2}) $ insertion sort, making bucket sort less optimal than $O(n\log_2n)$ comparison sort algorithms.</p>

<p>Examples:</p>

<table>
  <thead>
    <tr>
      <th>Input array</th>
      <th>Suitable algorithm</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1, 1, 1, 2, 2, 3, 3, 3, 4, 5, 5</td>
      <td>Counting sort</td>
    </tr>
    <tr>
      <td>1, 995, 996, 996, 998, 999</td>
      <td>Radix sort</td>
    </tr>
    <tr>
      <td>1, 1, 1, 1, 1000, 1000, 1000</td>
      <td>Bucket sort</td>
    </tr>
  </tbody>
</table>

  </div>

  <br> </br>
  <p><font color="grey" size="4"> Comments </font></p>
  <HR color=#D1D0CE SIZE=10>

<div id="disqus_thread"></div>

<script>
/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://walkermao.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


                            

  
</div>

      </section>
    </main><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-178951885-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-178951885-1');
</script>

    
    <div id="back-top">
      <a href="javascript:void(0);" onclick="topFunction()" title="Back to top"> </a>
    </div>

  </body>
</html>

<script src = "/assets/js/scroll_into_view.js"></script>
<script src = "/assets/js/back_to_top.js"></script>